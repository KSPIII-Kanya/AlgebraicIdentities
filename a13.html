<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kanya Sampoorna - Pythagorean Theorem</title>
    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Import CSS2DRenderer -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <!-- Import OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* --- STANDARD UI/UX CSS (PRESERVED) --- */
        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
            background-color: #f0f4f8;
            color: #333;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            position: relative; 
            width: 100%;
            background-color: #004a99;
            color: white;
            padding: 10px 20px;
            text-align: center;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            line-height: 1.4;
            flex-shrink: 0;
        }
        .header h1 { font-size: 1.5rem; font-weight: bold; margin: 0; }
        .header p { font-size: 0.9rem; margin: 0; }
        
        /* Footer */
        .footer {
            position: relative; 
            width: 100%;
            background-color: #004a99;
            color: white;
            padding: 8px;
            text-align: center;
            z-index: 10;
            font-size: 0.8rem;
            flex-shrink: 0;
        }

        /* Content Area */
        .content-area {
            flex-grow: 1; 
            display: flex;
            position: relative; 
            overflow: hidden; 
            height: 100%;
        }

        .main-container {
            display: flex;
            flex-direction: row;
            width: 100%;
            height: 100%;
        }

        /* Canvas Container */
        #canvas-container {
            position: relative;
            flex-grow: 1; 
            height: 100%;
            z-index: 1;
            overflow: hidden; 
            background-color: #fff;
            background-image: radial-gradient(#e0e0e0 1px, transparent 1px);
            background-size: 20px 20px;
            cursor: default;
        }
        
        canvas { display: block; width: 100%; height: 100%; outline: none; }

        /* 3D Labels */
        .math-label {
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            font-size: 20px;
            padding: 4px 8px;
            background-color: rgba(255, 255, 255, 0.9); /* Opaque background */
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            pointer-events: none; /* Let clicks pass through */
            white-space: nowrap;
        }

        /* Floating Formula - Bottom Aligned */
        #formula-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 25px;
            text-align: center;
            min-width: 300px; 
            background-color: rgba(255, 255, 255, 0.95);
            border: 3px solid #004a99;
            border-radius: 8px;
            pointer-events: none; 
            font-size: 1.5rem;
            font-weight: 900;
            font-family: 'Courier New', monospace;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 5;
        }

        .c-a { color: #2196F3; }
        .c-b { color: #FFC107; text-shadow: 1px 1px 0 #d4a000; }
        .c-c { color: #F44336; }

        /* UI Panel */
        .ui-panel {
            position: relative;
            flex-basis: 400px; 
            flex-shrink: 0;
            height: 100%;
            background-color: rgba(255, 255, 255, 1);
            border-left: 1px solid #ccc; 
            padding: 20px;
            z-index: 5;
            display: flex;
            flex-direction: column;
        }

        .ui-content {
            overflow-y: auto;
            flex-grow: 1; 
            padding-right: 5px; 
        }

        /* Interactive Step Cards */
        .step-card {
            background: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
            opacity: 0.6;
            pointer-events: none;
        }
        .step-card.active {
            background: #fff;
            border-color: #004a99;
            border-left: 5px solid #004a99;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            opacity: 1;
            pointer-events: auto;
        }
        .step-header h2 { font-size: 1.1rem; margin-bottom: 10px; color: #004a99; }
        .step-desc { font-size: 0.95rem; line-height: 1.5; color: #333; margin-bottom: 10px; }
        
        .action-box {
            background-color: #fff3e0;
            color: #e65100;
            padding: 8px;
            border-radius: 4px;
            font-weight: bold;
            text-align: center;
            font-size: 0.9rem;
            border: 1px solid #ffe0b2;
        }

        /* Button Navigation */
        .global-nav {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .sim-button {
            flex-basis: 48%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .sim-button:hover { box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        
        .sim-button.reset { background-color: #dc3545; }
        .sim-button.reset:hover { background-color: #c82333; }
        
        .sim-button.menu { background-color: #007bff; }
        .sim-button.menu:hover { background-color: #0056b3; }

        @media (max-width: 800px) {
            .content-area { flex-direction: column; }
            .main-container { flex-direction: column; }
            #canvas-container { flex-grow: 1; flex-basis: 60%; }
            .ui-panel { flex-basis: auto; flex-grow: 1; height: 40%; border-left: none; border-top: 1px solid #ccc; }
            #formula-container { width: 90%; min-width: auto; font-size: 1.2rem; }
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>Kanya Sampoorna Project 3.0 / Kanya Girls Education Project</h1>
        <p><b>The project is supported by TITAN and implemented by KALIKE</b></p>
        <p><b>AI-powered Math Simulation for fun, visual, and interactive learning of Algebraic Identities.</b></p>
    </div>
    
    <div class="content-area">
        <div class="main-container">
            <!-- Left Side: Canvas -->
            <div id="canvas-container">
                <div id="formula-container">
                    <span class="c-a">aÂ²</span> + 
                    <span class="c-b">bÂ²</span> = 
                    <span class="c-c">cÂ²</span>
                </div>
                <!-- Three.js will attach here -->
                <canvas id="simCanvas"></canvas>
            </div>

            <!-- Right Side: UI Panel -->
            <div class="ui-panel">
                <div class="ui-content">
                    
                    <!-- Navigation Buttons -->
                    <div class="global-nav">
                        <button class="sim-button reset" onclick="resetSimulation()">Reset</button>
                        <button class="sim-button menu" onclick="location.href='index.html'">Back to Menu</button>
                    </div>

                    <!-- Step 0 -->
                    <div id="step-0" class="step-card active">
                        <div class="step-header"><h2>Step 1: The Right Triangle</h2></div>
                        <div class="step-desc">
                            Observe the squares attached to the sides.
                            <ul>
                                <li><b style="color:#2196F3">Blue Square (aÂ²)</b></li>
                                <li><b style="color:#FFC107">Yellow Square (bÂ²)</b></li>
                                <li><b style="color:#F44336">Red Tray (cÂ²)</b> on the hypotenuse.</li>
                            </ul>
                        </div>
                        <div class="action-box">Goal: Fit Blue & Yellow into Red!</div>
                    </div>

                    <!-- Step 1 -->
                    <div id="step-1" class="step-card">
                        <div class="step-header"><h2>Step 2: The Slice</h2></div>
                        <div class="step-desc">
                            We need to cut the Yellow Square into 4 pieces. The cut lines are calculated using the slope of the hypotenuse (Perigal's Dissection).
                        </div>
                        <div class="action-box">ðŸ‘‰ Click the Yellow Square to Slice!</div>
                    </div>

                    <!-- Step 2 -->
                    <div id="step-2" class="step-card">
                        <div class="step-header"><h2>Step 3: The Proof</h2></div>
                        <div class="step-desc">
                            Now, <b>click on each piece</b> (the Blue Square and the 4 Yellow Fragments) to move them into the Red Tray.
                        </div>
                        <div class="action-box">Placed: <span id="count-display">0</span>/5</div>
                    </div>

                    <!-- Success Message -->
                    <div id="success-msg" class="step-card" style="border-color:#28a745; background-color:#d4edda; display:none; opacity:1;">
                        <div class="step-header"><h2 style="color:#155724">Proof Complete!</h2></div>
                        <div class="step-desc" style="color:#155724">
                            <b>L.H.S = R.H.S</b><br>
                            The pieces rearrange perfectly to form the square on the hypotenuse ($c^2$).
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        <b>Powered by AI and Created by Kalike - An initiative of TATA Trusts.</b>
    </div>

    <script>
        /* --- THREE.JS IMPLEMENTATION --- */
        let scene, camera, renderer, labelRenderer, controls;
        let raycaster, mouse;
        
        // State
        let step = 0; 
        let pieces = [];
        let squareA_Mesh, squareB_Mesh;
        
        // Config
        const A_SIZE = 3.0;
        const B_SIZE = 4.0;
        const EXPLODE_GAP = 3.5; 
        
        const COLORS = {
            a: 0x2196F3,      
            b: 0xFFC107,      
            c: 0xF44336,
            bg: 0xffffff
        };

        // Initialize Three.js
        function init() {
            const container = document.getElementById('canvas-container');
            const canvas = document.getElementById('simCanvas');
            
            // 1. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff); 
            
            const grid = new THREE.GridHelper(50, 50, 0xeeeeee, 0xeeeeee);
            grid.rotation.x = Math.PI / 2;
            scene.add(grid);

            // 2. Camera
            const aspect = container.clientWidth / container.clientHeight;
            camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            camera.position.set(0, 0, 26); 
            camera.lookAt(0, 0, 0);

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // 4. Label Renderer
            labelRenderer = new THREE.CSS2DRenderer();
            labelRenderer.setSize(container.clientWidth, container.clientHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none'; 
            container.appendChild(labelRenderer.domElement);

            // 5. Orbit Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 50;

            // 6. Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            // 7. Input
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('click', onMouseClick);
            window.addEventListener('resize', onResize);

            setupScenario();
            animate();
        }

        function onResize() {
            const container = document.getElementById('canvas-container');
            if (!camera || !renderer) return;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            labelRenderer.setSize(container.clientWidth, container.clientHeight);
        }

        function createLabel(text, color) {
            const div = document.createElement('div');
            div.className = 'math-label';
            div.textContent = text;
            div.style.color = '#' + color.toString(16).padStart(6, '0');
            const label = new THREE.CSS2DObject(div);
            return label;
        }

        function setupScenario() {
            // FIX: Explicitly remove all existing labels from the DOM to prevent stacking
            document.querySelectorAll('.math-label').forEach(el => el.remove());

            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
            pieces = [];
            step = 0;
            updateUI(0);

            // Re-add environment
            const grid = new THREE.GridHelper(50, 50, 0xe0e0e0, 0xe0e0e0);
            grid.rotation.x = Math.PI / 2;
            scene.add(grid);
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dl = new THREE.DirectionalLight(0xffffff, 0.8);
            dl.position.set(5, 10, 10); dl.castShadow=true; scene.add(dl);

            // Origin offset
            const origin = new THREE.Vector3(-2, 0, 0); 
            
            // Triangle (Visual)
            const triShape = new THREE.Shape();
            triShape.moveTo(0, 0); triShape.lineTo(0, -A_SIZE); triShape.lineTo(B_SIZE, 0); triShape.lineTo(0, 0);
            const triMesh = new THREE.Mesh(new THREE.ExtrudeGeometry(triShape, {depth:0.1, bevelEnabled:false}), new THREE.MeshLambertMaterial({color:0xeeeeee}));
            triMesh.position.set(origin.x, origin.y, 0);
            scene.add(triMesh);

            // Square A (Blue)
            const shapeA = new THREE.Shape();
            shapeA.moveTo(-A_SIZE/2, -A_SIZE/2); shapeA.lineTo(A_SIZE/2, -A_SIZE/2); 
            shapeA.lineTo(A_SIZE/2, A_SIZE/2); shapeA.lineTo(-A_SIZE/2, A_SIZE/2);
            
            squareA_Mesh = new THREE.Mesh(new THREE.ExtrudeGeometry(shapeA, {depth:0.2, bevelEnabled:true, bevelSize:0.02, bevelThickness:0.02}), new THREE.MeshLambertMaterial({color:COLORS.a}));
            squareA_Mesh.position.set(origin.x - A_SIZE/2 - EXPLODE_GAP, origin.y - A_SIZE/2, 0.05); 
            squareA_Mesh.castShadow = true;
            squareA_Mesh.userData = { type: 'a', isPlaced: false };
            scene.add(squareA_Mesh);

            // Label A
            const labelA = createLabel('aÂ²', COLORS.a);
            labelA.position.set(0, 0, 0);
            squareA_Mesh.add(labelA);

            // Square B (Yellow)
            const shapeB = new THREE.Shape();
            shapeB.moveTo(0,0); shapeB.lineTo(B_SIZE,0); shapeB.lineTo(B_SIZE,B_SIZE); shapeB.lineTo(0,B_SIZE);
            
            squareB_Mesh = new THREE.Mesh(new THREE.ExtrudeGeometry(shapeB, {depth:0.2, bevelEnabled:true, bevelSize:0.02, bevelThickness:0.02}), new THREE.MeshLambertMaterial({color:COLORS.b}));
            squareB_Mesh.position.set(origin.x, origin.y + EXPLODE_GAP, 0.05); 
            squareB_Mesh.userData = { type: 'b_whole' };
            squareB_Mesh.castShadow = true;
            scene.add(squareB_Mesh);

            // Label B
            const labelB = createLabel('bÂ²', COLORS.b);
            labelB.position.set(B_SIZE/2, B_SIZE/2, 0);
            squareB_Mesh.add(labelB);

            // Square C Tray
            const C_SIZE = Math.sqrt(A_SIZE*A_SIZE + B_SIZE*B_SIZE);
            const trayGroup = new THREE.Group();
            
            // Tray Base
            const base = new THREE.Mesh(new THREE.PlaneGeometry(C_SIZE, C_SIZE), new THREE.MeshBasicMaterial({color:0xffcccc, side:THREE.DoubleSide, transparent:true, opacity:0.3}));
            trayGroup.add(base);
            
            // Tray Borders
            const thickness = 0.15;
            const borderMat = new THREE.MeshLambertMaterial({color: COLORS.c});
            const b1 = new THREE.Mesh(new THREE.BoxGeometry(C_SIZE + thickness, thickness, 0.2), borderMat); b1.position.y = C_SIZE/2;
            const b2 = new THREE.Mesh(new THREE.BoxGeometry(C_SIZE + thickness, thickness, 0.2), borderMat); b2.position.y = -C_SIZE/2;
            const b3 = new THREE.Mesh(new THREE.BoxGeometry(thickness, C_SIZE, 0.2), borderMat); b3.position.x = C_SIZE/2;
            const b4 = new THREE.Mesh(new THREE.BoxGeometry(thickness, C_SIZE, 0.2), borderMat); b4.position.x = -C_SIZE/2;
            trayGroup.add(b1, b2, b3, b4);

            // Label C
            const labelC = createLabel('cÂ²', COLORS.c);
            labelC.position.set(0, 0, 0);
            trayGroup.add(labelC);

            // Position Tray (Rotated by angle)
            const p2 = new THREE.Vector3(origin.x, origin.y - A_SIZE, 0);
            const p3 = new THREE.Vector3(origin.x + B_SIZE, origin.y, 0);
            const mid = new THREE.Vector3().addVectors(p2, p3).multiplyScalar(0.5);
            const angle = Math.atan2(A_SIZE, B_SIZE);
            
            trayGroup.rotation.z = angle;
            // Move tray center "out" perpendicular to hypotenuse
            const perpX = -Math.sin(angle);
            const perpY = Math.cos(angle);
            trayGroup.position.x = mid.x + perpX * (C_SIZE/2);
            trayGroup.position.y = mid.y + perpY * (C_SIZE/2);
            trayGroup.position.z = -0.05; 
            scene.add(trayGroup);
            
            window.trayCenter = trayGroup.position.clone();
            window.trayRotation = angle;

            window.targetA = { 
                pos: new THREE.Vector3(window.trayCenter.x, window.trayCenter.y, 0.05), 
                rot: 0 
            };
        }

        function triggerSlice() {
            if (step !== 0) return;
            
            // FIX: Explicitly remove labels from B mesh
            squareB_Mesh.children.forEach(child => {
                if (child.isCSS2DObject) squareB_Mesh.remove(child);
            });

            scene.remove(squareB_Mesh); 
            pieces = [];

            // Perigal's Dissection Geometry
            const h = B_SIZE / 2;
            const slope = A_SIZE / B_SIZE;
            const C_SIZE = Math.sqrt(A_SIZE*A_SIZE + B_SIZE*B_SIZE);
            
            const y1 = h * slope; 
            const x2 = h * slope;
            const pRight = new THREE.Vector2(h, y1);
            const pTop = new THREE.Vector2(-x2, h);
            const pLeft = new THREE.Vector2(-h, -y1);
            const pBot = new THREE.Vector2(x2, -h);
            const cTR = new THREE.Vector2(h, h);
            const cTL = new THREE.Vector2(-h, h);
            const cBL = new THREE.Vector2(-h, -h);
            const cBR = new THREE.Vector2(h, -h);
            
            const shapes = [
                new THREE.Shape([new THREE.Vector2(0,0), pRight, cTR, pTop]), // 0: Top Right
                new THREE.Shape([new THREE.Vector2(0,0), pTop, cTL, pLeft]),  // 1: Top Left
                new THREE.Shape([new THREE.Vector2(0,0), pLeft, cBL, pBot]),  // 2: Bottom Left
                new THREE.Shape([new THREE.Vector2(0,0), pBot, cBR, pRight])  // 3: Bottom Right
            ];
            
            const origin = new THREE.Vector3(-2, 0, 0); 
            const bWorldCenter = new THREE.Vector3(origin.x + B_SIZE/2, origin.y + B_SIZE/2 + EXPLODE_GAP, 0.05);

            const trayRot = window.trayRotation;
            const trayPos = window.trayCenter;
            const trayHalf = C_SIZE / 2;
            const angle = Math.atan2(A_SIZE, B_SIZE);

            const targetOffsets = [
                new THREE.Vector3(trayHalf, trayHalf, 0),    // Piece 0 (TR) -> TR Corner of C
                new THREE.Vector3(-trayHalf, trayHalf, 0),   // Piece 1 (TL) -> TL Corner of C
                new THREE.Vector3(-trayHalf, -trayHalf, 0),  // Piece 2 (BL) -> BL Corner of C
                new THREE.Vector3(trayHalf, -trayHalf, 0)    // Piece 3 (BR) -> BR Corner of C
            ];

            shapes.forEach((sh, i) => {
                const geom = new THREE.ExtrudeGeometry(sh, { depth: 0.2, bevelEnabled: true, bevelSize: 0.02, bevelThickness: 0.02 });
                const mat = new THREE.MeshLambertMaterial({ color: COLORS.b });
                const mesh = new THREE.Mesh(geom, mat);
                
                mesh.position.copy(bWorldCenter);
                mesh.castShadow = true;
                
                const localVec = targetOffsets[i].clone();
                localVec.applyAxisAngle(new THREE.Vector3(0,0,1), trayRot);
                const finalPos = trayPos.clone().add(localVec);
                finalPos.z = 0.05;

                const finalRot = trayRot - angle + Math.PI;

                mesh.userData = {
                    type: 'b_frag', isPlaced: false,
                    startPos: bWorldCenter.clone(), 
                    targetPos: finalPos,
                    startRot: 0, 
                    targetRot: finalRot 
                };
                
                const expDir = new THREE.Vector3((i===0||i===3)?1:-1, (i===0||i===1)?1:-1, 0).multiplyScalar(0.2);
                mesh.position.add(expDir);
                
                scene.add(mesh);
                pieces.push(mesh);
            });

            step = 2; // Move to proof step
            updateUI(2);
        }

        function movePiece(mesh, duration = 1000) {
            if (mesh.userData.isPlaced) return;
            
            // FIX: Remove any labels attached to this piece (for Square A)
            const labels = mesh.children.filter(child => child.isCSS2DObject);
            labels.forEach(l => mesh.remove(l));
            
            const startPos = mesh.position.clone();
            const endPos = mesh.userData.type === 'a' ? window.targetA.pos : mesh.userData.targetPos;
            const startRot = mesh.rotation.z;
            const endRot = mesh.userData.type === 'a' ? window.targetA.rot : mesh.userData.targetRot;
            
            const midPos = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
            midPos.z += 8; 

            let startTime = null;

            function anim(time) {
                if (!startTime) startTime = time;
                const progress = Math.min((time - startTime) / duration, 1);
                
                const t = 1 - Math.pow(1 - progress, 3);
                
                const p0 = startPos; const p1 = midPos; const p2 = endPos;
                mesh.position.x = (1-t)*(1-t)*p0.x + 2*(1-t)*t*p1.x + t*t*p2.x;
                mesh.position.y = (1-t)*(1-t)*p0.y + 2*(1-t)*t*p1.y + t*t*p2.y;
                mesh.position.z = (1-t)*(1-t)*p0.z + 2*(1-t)*t*p1.z + t*t*p2.z;
                
                mesh.rotation.z = startRot + (endRot - startRot) * t;

                if (progress < 1) {
                    requestAnimationFrame(anim);
                } else {
                    mesh.userData.isPlaced = true;
                    updateUIProgress();
                }
            }
            requestAnimationFrame(anim);
        }

        function onMouseMove(event) {
            event.preventDefault();
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            let clickables = [];
            if (step === 0) {
                clickables = scene.children.filter(c => c.userData.type === 'b_whole');
            } else if (step === 2) {
                clickables = [...pieces, squareA_Mesh].filter(p => !p.userData.isPlaced);
            }

            const intersects = raycaster.intersectObjects(clickables);
            document.body.style.cursor = (intersects.length > 0) ? 'pointer' : 'default';
        }

        function onMouseClick(event) {
            event.preventDefault();
            raycaster.setFromCamera(mouse, camera);
            
            if (step === 0) {
                const intersects = raycaster.intersectObjects(scene.children);
                if (intersects.length > 0 && intersects[0].object.userData.type === 'b_whole') {
                    triggerSlice();
                }
            } else if (step === 2) {
                const clickables = [...pieces, squareA_Mesh];
                const intersects = raycaster.intersectObjects(clickables);
                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    if ((obj.userData.type === 'a' || obj.userData.type === 'b_frag') && !obj.userData.isPlaced) {
                        movePiece(obj);
                    }
                }
            }
        }

        function updateUIProgress() {
            let placed = 0;
            if (squareA_Mesh && squareA_Mesh.userData.isPlaced) placed++;
            pieces.forEach(p => { if(p.userData.isPlaced) placed++; });
            document.getElementById('count-display').innerText = placed;
            if (placed === 5) document.getElementById('success-msg').style.display = 'block';
        }
        
        function updateUI(currentStep) {
            ['step-0', 'step-1', 'step-2'].forEach((id, idx) => {
                const el = document.getElementById(id);
                if (idx === currentStep) el.classList.add('active'); else el.classList.remove('active');
            });
            if (currentStep === 0) { 
                document.getElementById('success-msg').style.display = 'none'; 
                document.getElementById('count-display').innerText = "0"; 
            }
        }

        function resetSimulation() { setupScenario(); }
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>