<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kanya Sampoorna Project 3.0 - (a - b)³</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    
    <style>
        /* Basic Reset and Font */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
            background-color: #f0f4f8;
            color: #333;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            position: relative; 
            width: 100%;
            background-color: #004a99; /* Titan/Kalike Blue */
            color: white;
            padding: 10px 20px;
            text-align: center;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            line-height: 1.4;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 1.5rem; 
            font-weight: bold;
            margin: 0;
        }

        .header p {
            font-size: 0.9rem;
            margin: 0;
        }
        
        /* Footer */
        .footer {
            position: relative; 
            width: 100%;
            background-color: #004a99;
            color: white;
            padding: 8px;
            text-align: center;
            z-index: 10;
            font-size: 0.8rem;
            flex-shrink: 0;
        }

        /* Content Area Wrapper */
        .content-area {
            flex-grow: 1; 
            display: flex;
            position: relative; 
            overflow: hidden; 
            height: 100%;
        }

        /* Main Layout Container */
        .main-container {
            display: flex;
            flex-direction: row; /* Side-by-side */
            width: 100%;
            height: 100%;
        }

        /* Scene container */
        #scene-container {
            position: relative;
            flex-grow: 1; 
            height: 100%;
            z-index: 1;
            overflow: hidden; 
        }
        
        /* 3D Label CSS */
        .label {
            color: #111;
            font-family: Arial, sans-serif;
            font-size: 18px; /* Increased font size */
            font-weight: bold; /* Made labels bold */
            background-color: rgba(255, 255, 255, 0.9); /* Slightly less transparent */
            padding: 6px 10px; /* Increased padding */
            border-radius: 6px; /* Slightly larger border radius */
            border: 1px solid #666; /* Darker border */
            pointer-events: none; /* So they don't block clicks */
            white-space: nowrap; /* Prevent line breaks */
            /* Add a shadow for better visibility */
            text-shadow: 0 0 2px white, 0 0 2px white, 0 0 2px white;
        }

        /* New: Dimension Labels (for side lengths) */
        .dim-label {
            color: #000;
            font-family: "Courier New", Courier, monospace;
            font-size: 16px;
            font-weight: bold;
            background-color: rgba(255, 255, 255, 0.85);
            padding: 2px 5px;
            border-radius: 4px;
            pointer-events: none;
            white-space: nowrap;
        }

        /* UI Panel (right-side column) */
        .ui-panel {
            position: relative;
            flex-basis: 400px; 
            flex-shrink: 0;
            height: 100%;
            background-color: rgba(255, 255, 255, 1);
            border-left: 1px solid #ccc; 
            padding: 20px;
            z-index: 5;
            display: flex;
            flex-direction: column;
        }

        .ui-content {
            max-height: none;
            overflow-y: auto;
            flex-grow: 1; 
            padding-right: 10px; 
        }

        /* Step Navigation Styling */
        .step-header {
            cursor: pointer;
            padding: 12px 10px;
            border-radius: 8px;
            margin-bottom: 5px;
            background-color: #f4f4f4;
            transition: background-color 0.2s;
            border: 1px solid #eee;
        }
        
        .step-header:hover {
            background-color: #e9e9e9;
        }

        .step-header.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        .step-header h2 {
            font-size: 1.1rem;
            margin-bottom: 0;
            color: #004a99;
        }
        
        .step-header.active h2 {
            color: white;
        }

        .step-description {
            display: none; /* Hidden by default */
            padding: 10px 10px 15px 10px;
            border-bottom: 1px solid #eee;
            margin-bottom: 5px;
            background: #fafafa;
        }

        .step-header.active + .step-description {
            display: block; /* Show description for active step */
        }
        
        .step-description p {
            font-size: 0.95rem;
            line-height: 1.5;
            margin-bottom: 10px;
            font-weight: bold; /* Make all step descriptions bold */
        }
        
        .step-description p:last-child {
            margin-bottom: 0;
        }
        
        /* New: Button styles */
        .sim-button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            transition: background-color 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .sim-button:hover {
            background-color: #0056b3;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .sim-button:disabled {
            background-color: #c0c0c0;
            cursor: not-allowed;
            box-shadow: none;
        }

        .sim-button.success {
            background-color: #28a745;
        }

        /* Interactive Feedback Text */
        .feedback {
            font-weight: bold;
            color: #004a99; /* Blue */
            background-color: #f4f8ff;
            border: 1px solid #b5cde5;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            transition: all 0.2s;
        }
        
        .feedback.subtract {
            color: #d9534f; /* Red/emphasis color */
            background-color: #fff8f8;
            border: 1px solid #f0c0c0;
        }

        .feedback.success {
            color: #3c763d; /* Green */
            background-color: #f4fcf4;
            border-color: #b5d5b5;
        }
        
        /* Algebra explanation styles */
        .algebra {
            background-color: #e6f0ff;
            border-radius: 8px;
            padding: 10px;
            font-family: "Courier New", Courier, monospace;
            font-size: 0.95rem;
            line-height: 1.6;
            margin-top: 10px;
        }
        .term {
            font-weight: bold;
        }
        .term-a3 { color: #004a99; } /* a³ */
        .term-amb3 { color: #007bff; } /* (a-b)³ */
        .term-3a2b { color: #f0ad4e; } /* 3a²b */
        .term-3ab2 { color: #5cb85c; } /* 3ab² */
        .term-b3 { color: #d9534f; } /* b³ */

        /* NEW: Specific term for 2D formula */
        .term-a2 { color: #004a99; } /* a² */
        .term-amb2 { color: #007bff; } /* (a-b)² */
        .term-2ab { color: #f0ad4e; } /* 2ab */
        .term-b2 { color: #d9534f; } /* b² */
        
        /* Loading Screen */
        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            color: #004a99;
            z-index: 100;
        }

        /* Responsive layout for tablet/mobile */
        @media (max-width: 800px) {
            .content-area {
                flex-direction: column; 
            }
            
            .main-container {
                flex-direction: column; 
            }

            #scene-container {
                flex-grow: 1;
                flex-basis: 60%; 
                height: 60%;
                width: 100%;
            }

            .ui-panel {
                flex-basis: auto; 
                flex-grow: 1; 
                height: 40%;
                width: 100%;
                border-left: none;
                border-top: 1px solid #ccc;
                padding: 15px;
            }
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>Kanya Sampoorna Project 3.0 / Kanya Girls Education Project</h1>
        <p><b>The project is supported by TITAN and implemented by KALIKE</b></p>
        <p><b>AI-powered Math Simulation for fun, visual, and interactive learning of Algebraic Identities.</b></p>
    </div>
    
    <div class="content-area">
        <div id="loader">Loading 3D Simulation...</div>

        <div class="main-container">
            <div id="scene-container"></div>

            <div class="ui-panel">
                <div class="ui-content">
                    
                    <div class="step-header active" onclick="goToStep(0)">
                        <h2>Step 0: Welcome!</h2>
                    </div>
                    <div class="step-description" id="step-0-desc">
                        <p><b>Hello! Let's go on a journey to discover the formula for (a - b)³.
                            <br><br>We will start with a simple 1D line, move to a 2D square, and then use that logic to solve the 3D cube!</b>
                        </p>
                    </div>
                    
                    <div class="step-header" onclick="goToStep(1)">
                        <h2>Step 1: The 1D Journey (a-b)</h2>
                    </div>
                    <div class="step-description" id="step-1-desc">
                        <p><b>Let's start with a simple 1D line of length 'a'.
                            <br><br>We want to find the length (a-b) by splitting 'a' into two parts: (a-b) and 'b'.</b>
                        </p>
                        <button id="step-1-btn-1" class="sim-button" onclick="handleStep1Click(1)">Split Line 'a'</button>
                        <button id="step-1-btn-2" class="sim-button" onclick="handleStep1Click(2)" style="display: none;">Remove 'b'</button>
                        <button id="step-1-btn-reset" class="sim-button" onclick="handleStep1Click(3)" style="display: none; background-color: #6c757d; margin-top: 5px;">Reset Line</button>
                    </div>
                    
                    <div class="step-header" onclick="goToStep(2)">
                        <h2>Step 2: The 2D Journey (a-b)²</h2>
                    </div>
                    <div class="step-description" id="step-2-desc">
                         <p id="step-2-text"><b>Now, let's apply that same logic to a 2D square with area a².
                            <br><br>We will split the square by "cutting" it. This is a two-step process.</b>
                        </p>
                        <button id="step-2-btn-1" class="sim-button" onclick="handleStep2Click(1)">1. Make Vertical Split</button>
                        <button id="step-2-btn-2" class="sim-button" onclick="handleStep2Click(2)" style="display: none;">2. Make Horizontal Split</button>
                        <button id="step-2-btn-reset" class="sim-button" onclick="handleStep2Click(3)" style="display: none; background-color: #6c757d; margin-top: 5px;">Merge & Replay Split</button>
                    
                        <!-- NEW: Hidden formula div -->
                        <div id="step-2-formula" style="display: none; margin-top: 15px;">
                            <p><b>From the visual, we see that the big a² square is made of 4 pieces:</b></p>
                            <div class="algebra" style="font-size: 1.1rem; line-height: 1.7; font-weight: bold;">
                                <span class="term term-a2">a²</span> = 
                                <span class="term term-amb2">(a-b)²</span> + 
                                <span class="term term-2ab">b(a-b)</span> + 
                                <span class="term term-2ab">b(a-b)</span> + 
                                <span class="term term-b2">b²</span>
                            </div>
                            <p style="margin-top: 10px;"><b>If we simplify and rearrange this to solve for (a-b)², we get the famous formula:</b></p>
                            <div class="algebra" style="font-size: 1.1rem; line-height: 1.7; font-weight: bold;">
                                <span class="term term-amb2">(a-b)²</span> = 
                                <span class="term term-a2">a²</span> - 
                                <span class="term term-2ab">2ab</span> + 
                                <span class="term term-b2">b²</span>
                            </div>
                        </div>
                    </div>

                    <div class="step-header" onclick="goToStep(3)">
                        <h2>Step 3: The 3D Journey (a-b)³</h2>
                    </div>
                    <div class="step-description" id="step-3-desc">
                        <p id="step-3-text"><b>Great! Now we apply the *exact same logic* to 3D.
                            <br><br>We start with a big cube of volume a³.</b>
                        </p>
                        <!-- New feedback div for 3D interaction -->
                        <div class="feedback" id="step-3-feedback" style="margin-top: 15px;">Click the cube to begin.</div>
                        
                        <button id="step-3-btn-reset" class="sim-button" onclick="goToStep(3)" style="display: none; background-color: #6c757d; margin-top: 5px;">Reset 3D Cube</button>
                        
                        <!-- NEW: Hidden formula div (moved from old steps) -->
                        <div id="step-3-formula" style="display: none; margin-top: 15px;">
                            <p><b>You did it! The only piece left is our goal, the blue (a-b)³ cube.</b></p>
                            <p style="margin-top: 10px;"><b>We have just proved this visual formula:</b></p>
                             <div class="algebra">
                                <b>(a-b)³ = <br>a³ - 3b(a-b)² - 3b²(a-b) - b³</b>
                                <br><br><b>(The blue cube = the big cube - 3 slabs - 3 sticks - 1 corner).</b>
                            </div>
                            <p style="margin-top: 10px;"><b>If we expand all those terms and simplify them, we get the famous algebraic formula:</b></p>
                            <div class="algebra">
                                <span class="term term-amb3">(a-b)³</span> = 
                                <span class="term term-a3">a³</span> -
                                <span class="term term-3a2b">3a²b</span> +
                                <span class="term term-3ab2">3ab²</span> -
                                <span class="term term-b3">b³</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- REMOVED STEPS 4-12 -->
                    
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        <b>Powered by AI and Created by Kalike - An initiative of TATA Trusts.</b>
    </div>

    <script>
        
        let scene, camera, renderer, controls, labelRenderer;
        let mainGroup; // A group to hold all cubes
        let currentStep = 0;
        
        let raycaster, mouse;
        
        const stepState = {
            // Step 1
            step1_a_clicked: false, 
            step1_b_removed: false, 
            
            // Step 2
            step2_vertical_split: false, 
            step2_horizontal_split: false,
            
            // Step 3 (NEW)
            step3_stage: 0, // 0: Start, 1: Remove Slabs, 2: Remove Sticks, 3: Remove Corner, 4: Done
            step3_piecesLeft: 0,
        };
        
        // Store meshes that are "flying away"
        let flyAwayMeshes = [];
        // Store planes that are animating
        let animatingObjects = []; // NEW: Unified animation array

        const materials = {
            // 3D Meshes
            main: new THREE.MeshLambertMaterial({ color: 0x007bff, userData: { originalColor: 0x007bff } }),
            slab: new THREE.MeshLambertMaterial({ color: 0x5cb85c, userData: { originalColor: 0x5cb85c } }),
            slab2: new THREE.MeshLambertMaterial({ color: 0x5cb85c, userData: { originalColor: 0x5cb85c } }), // NEW: Unique material
            slab3: new THREE.MeshLambertMaterial({ color: 0x5cb85c, userData: { originalColor: 0x5cb85c } }), // NEW: Unique material
            stick: new THREE.MeshLambertMaterial({ color: 0xf0ad4e, userData: { originalColor: 0xf0ad4e } }),
            stick2: new THREE.MeshLambertMaterial({ color: 0xf0ad4e, userData: { originalColor: 0xf0ad4e } }), // NEW: Unique material
            stick3: new THREE.MeshLambertMaterial({ color: 0xf0ad4e, userData: { originalColor: 0xf0ad4e } }), // NEW: Unique material
            corner: new THREE.MeshLambertMaterial({ color: 0xd9534f, userData: { originalColor: 0xd9534f } }),
            outline: new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }),
            a_cube: new THREE.MeshLambertMaterial({ color: 0x004a99, transparent: false, opacity: 1, userData: { originalColor: 0x004a99 } }),
            
            // 2D Planes
            a_plane: new THREE.MeshBasicMaterial({ color: 0x004a99, side: THREE.DoubleSide, transparent: true, opacity: 0.6, userData: { originalColor: 0x004a99 } }),
            main_plane: new THREE.MeshBasicMaterial({ color: 0x007bff, side: THREE.DoubleSide, userData: { originalColor: 0x007bff } }),
            b_plane: new THREE.MeshBasicMaterial({ color: 0xd9534f, side: THREE.DoubleSide, userData: { originalColor: 0xd9534f } }),
            amb_plane: new THREE.MeshBasicMaterial({ color: 0xf0ad4e, side: THREE.DoubleSide, userData: { originalColor: 0xf0ad4e } }), // 2d rects
            // NEW: 2D Vertical Split Panes
            vert_plane_amb: new THREE.MeshBasicMaterial({ color: 0x007bff, side: THREE.DoubleSide, transparent: true, opacity: 0.8, userData: { originalColor: 0x007bff } }),
            vert_plane_b: new THREE.MeshBasicMaterial({ color: 0xd9534f, side: THREE.DoubleSide, transparent: true, opacity: 0.8, userData: { originalColor: 0xd9534f } }),


            // 1D "Line" Materials (using thin boxes)
            line_a: new THREE.MeshLambertMaterial({ color: 0x28a745, userData: { originalColor: 0x28a745 } }), // Green for 'a'
            line_b: new THREE.MeshLambertMaterial({ color: 0xd9534f, userData: { originalColor: 0xd9534f } }), // Red
            line_amb: new THREE.MeshLambertMaterial({ color: 0x007bff, userData: { originalColor: 0x007bff } }), // Blue
        };
        
        const geometries = {};
        const meshes = {}; // 3D cubes
        const lines = {}; // 1D "Line" Meshes
        const planes = {}; // 2D planes
        const labels = {}; // 2D HTML Labels
        
        let valA = 5;
        let valB = 2;
        let valAminusB = 3;
        
        const loader = document.getElementById('loader');

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f4f8);

            // Renderer
            const container = document.getElementById('scene-container');
            if (!container) {
                console.error("Scene container not found!");
                return;
            }
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(container.clientWidth, container.clientHeight);

            // Set explicit position, z-index, and cursor on the canvas
            renderer.domElement.style.position = 'relative';
            renderer.domElement.style.zIndex = 0;
            renderer.domElement.style.cursor = 'pointer';

            container.appendChild(renderer.domElement);
            
            // Label Renderer (CSS2D)
            labelRenderer = new THREE.CSS2DRenderer(); 
            labelRenderer.setSize(container.clientWidth, container.clientHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0';
            labelRenderer.domElement.style.pointerEvents = 'none'; // Allow clicks to pass through
            labelRenderer.domElement.style.zIndex = 1; // z-index on the label container
            container.appendChild(labelRenderer.domElement);

            // Camera
            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;

            // Main Group
            mainGroup = new THREE.Group();
            scene.add(mainGroup);
            
            // Raycaster
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            
            // *** THE FIX: Listen on the canvas (renderer.domElement) ***
            renderer.domElement.addEventListener('click', onMouseClick);
            
            // Build all assets
            createGeometries();
            createMeshes();
            createLineMeshes();
            create2DPlanes();
            createLabels();
            
            // Start
            goToStep(0);
            animate();
            
            if (loader) loader.style.display = 'none';
        }

        // Main animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // flyAwayAnimation(); // OLD
            runActiveAnimations(); // Run all position/fade animations
            
            if (controls) controls.update();
            if (renderer) renderer.render(scene, camera);
            if (labelRenderer) labelRenderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('scene-container');
            if (!container || !camera || !renderer) return; 

            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            if (labelRenderer) labelRenderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        // This function captures the click event,
        // finds the clicked object, and passes it to handleInteraction.
        function onMouseClick(event) {
            
            // *** Calculate mouse position relative to the canvas ***
            const rect = renderer.domElement.getBoundingClientRect();
            
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            // FIX: Intersect only the main objects, not outlines
            const objectsToIntersect = mainGroup.children.filter(child => child.isMesh && child.visible);
            const intersects = raycaster.intersectObjects(objectsToIntersect, false); // false = don't check children

            if (intersects.length > 0) {
                let clickedObject = intersects[0].object;
                
                // Note: No need to traverse up since we're not intersecting outlines
                
                handleInteraction(clickedObject); // Call the handler
            }
        }

        // This function handles the logic for *what* to do with a clicked object.
        function handleInteraction(clickedObject) {
            
            // Define piece types for 3D interaction (flashing only)
            const stickMeshes = [meshes.stick1, meshes.stick2, meshes.stick3];
            const slabMeshes = [meshes.slab1, meshes.slab2, meshes.slab3];
            
            let pieceType = '';
            if (slabMeshes.includes(clickedObject)) pieceType = 'slab';
            if (stickMeshes.includes(clickedObject)) pieceType = 'stick';
            if (clickedObject === meshes.corner) pieceType = 'corner';
            
            // --- Step 1-2 Logic is now in button handlers ---
            
            // --- NEW: Step 3 Interactive Logic ---
            if (currentStep === 3) {
                // Stage 0: Waiting for user to click the 'a3' cube to start
                if (stepState.step3_stage === 0) {
                    if (clickedObject === meshes.a_cube) {
                        // Start the puzzle!
                        stepState.step3_stage = 1; // Advance to slab removal
                        stepState.step3_piecesLeft = 3;
                        
                        // Start fading out a3 cube - NO, make it instant
                        meshes.a_cube.visible = false;
                        setLabelGroupVisibility(['a_cube'], false);
                        
                        // Show all 8 pieces and animate them to EXPLODED view
                        const allPieces = [meshes.main, meshes.slab1, meshes.slab2, meshes.slab3, meshes.stick1, meshes.stick2, meshes.stick3, meshes.corner];
                        allPieces.forEach(mesh => {
                            mesh.visible = true;
                            const startPos = getAssembledPosition(mesh); // Start assembled
                            const endPos = get3DExplodedPos(mesh); // End exploded
                            mesh.position.copy(startPos);
                            startAnimation(mesh, endPos, null, 0.03); // Animate to exploded pos
                        });
                        // Show all their labels
                        setLabelGroupVisibility(['amb_cube', 'slab', 'slab2', 'slab3', 'stick', 'stick2', 'stick3', 'corner'], true); 
                        
                        updateFeedback();
                    } else if (pieceType) {
                        flashWrong(clickedObject);
                    }
                }
                
                // Stage 1: Removing Slabs
                else if (stepState.step3_stage === 1) {
                    if (pieceType === 'slab' && clickedObject.visible && !clickedObject.userData.isRemoving) {
                        // removePiece(clickedObject); // OLD: Fade out
                        clickedObject.visible = false; // NEW: Instant hide
                        clickedObject.userData.isRemoving = true; // Flag as removed
                        setLabelGroupVisibility([getLabelForMesh(clickedObject)], false); // Hide its label
                        
                        stepState.step3_piecesLeft--;
                        if (stepState.step3_piecesLeft === 0) {
                            stepState.step3_stage = 2; // Advance to stick removal
                            stepState.step3_piecesLeft = 3;
                            // NEW: Hide all slabs
                            slabMeshes.forEach(mesh => {
                                if (mesh.userData.isRemoving) mesh.visible = false;
                            });
                        }
                        updateFeedback();
                    } else if (pieceType && clickedObject.visible && !clickedObject.userData.isRemoving) {
                        flashWrong(clickedObject); // Clicked wrong piece
                    }
                }
                
                // Stage 2: Removing Sticks
                else if (stepState.step3_stage === 2) {
                    if (pieceType === 'stick' && clickedObject.visible && !clickedObject.userData.isRemoving) {
                        // removePiece(clickedObject); // OLD
                        clickedObject.visible = false; // NEW: Instant hide
                        clickedObject.userData.isRemoving = true;
                        setLabelGroupVisibility([getLabelForMesh(clickedObject)], false);

                        stepState.step3_piecesLeft--;
                        if (stepState.step3_piecesLeft === 0) {
                            stepState.step3_stage = 3; // Advance to corner removal
                            stepState.step3_piecesLeft = 1;
                            // NEW: Hide all sticks
                            stickMeshes.forEach(mesh => {
                                if (mesh.userData.isRemoving) mesh.visible = false;
                            });
                        }
                        updateFeedback();
                    } else if (pieceType && clickedObject.visible && !clickedObject.userData.isRemoving) {
                        flashWrong(clickedObject); // Clicked wrong piece
                    }
                }
                
                // Stage 3: Removing Corner
                else if (stepState.step3_stage === 3) {
                    if (pieceType === 'corner' && clickedObject.visible && !clickedObject.userData.isRemoving) {
                        // removePiece(clickedObject); // OLD
                        clickedObject.visible = false; // NEW: Instant hide
                        clickedObject.userData.isRemoving = true;
                        setLabelGroupVisibility([getLabelForMesh(clickedObject)], false);

                        stepState.step3_piecesLeft--;
                        if (stepState.step3_piecesLeft === 0) {
                            stepState.step3_stage = 4; // Done!
                            // NEW: Hide corner
                            meshes.corner.visible = false;
                        }
                        updateFeedback();
                    } else if (pieceType && clickedObject.visible && !clickedObject.userData.isRemoving) {
                        flashWrong(clickedObject); // Clicked wrong piece
                    }
                }
                
                // Stage 4: Done (just clicking the final cube)
                else if (stepState.step3_stage === 4) {
                    if (clickedObject === meshes.main) {
                        flashWrong(clickedObject); // Flash to show it's the final piece
                    }
                }
            }
            
            // --- Old Step 5 Logic (now part of Step 3) ---
            else if (currentStep === 5 && pieceType && clickedObject.visible) {
                 // This step is no longer used, logic is in step 3
                 // But we keep the flash for other steps
            } else if (pieceType) {
                 flashWrong(clickedObject);
            }
        } 
        
        // Animate removing a piece (FADE OUT)
        function removePiece(mesh) {
            // NEW FIX: This function is now only for 1D/2D lines
            if (!mesh || mesh.userData.isRemoving) return;
            
            mesh.userData.isRemoving = true;
            mesh.userData.isFlashing = false; 
            
            // Hide label immediately
            mesh.children.forEach(child => {
                if (child.isCSS2DObject) child.visible = false;
            });
            
            // Start a fade-out animation
            startAnimation(mesh, null, 0.0, 0.05); // Fade to 0 opacity
        }
        
        // --- NEW: Unified Animation System ---
        
        /**
         * Starts an animation for a mesh.
         * @param {THREE.Mesh} mesh - The mesh to animate.
         * @param {THREE.Vector3 | null} endPos - The target position (or null to not move).
         * @param {number | null} endOpacity - The target opacity (or null to not fade).
         * @param {number} speed - The animation speed (0.01 to 1.0).
         */
        function startAnimation(mesh, endPos, endOpacity, speed = 0.05) {
            // Ensure material is transparent if opacity is targeted
            if (endOpacity !== null && !mesh.material.transparent) {
                mesh.material.transparent = true;
            }

            const animation = {
                mesh: mesh,
                startPos: new THREE.Vector3().copy(mesh.position),
                endPos: endPos ? new THREE.Vector3().copy(endPos) : null,
                startOpacity: mesh.material.opacity,
                endOpacity: endOpacity,
                progress: 0,
                speed: speed
            };
            
            animatingObjects.push(animation);
        }

        // Animation loop for all active animations
        function runActiveAnimations() {
            if (animatingObjects.length === 0) return;

            animatingObjects = animatingObjects.filter(item => {
                item.progress += item.speed;
                let isComplete = false;

                if (item.progress >= 1) {
                    item.progress = 1;
                    isComplete = true;
                }
                
                // Ease-out cubic function for smooth stopping
                const easeProgress = 1 - Math.pow(1 - item.progress, 3);
                
                // Animate Position
                if (item.endPos) {
                    item.mesh.position.lerpVectors(item.startPos, item.endPos, easeProgress);
                }
                
                // Animate Opacity
                if (item.endOpacity !== null) {
                    item.mesh.material.opacity = item.startOpacity + (item.endOpacity - item.startOpacity) * easeProgress;
                }

                if (isComplete) {
                    if (item.endOpacity === 0.0) {
                        item.mesh.visible = false; // Hide if faded out
                        item.mesh.userData.isRemoving = false;
                    }
                    return false; // Remove from list
                }
                
                return true; // Keep in list
            });
        }
        
        // --- OLD flyAwayAnimation (replaced by runActiveAnimations) ---
        function flyAwayAnimation() {
            // This function is now OBSOLETE.
            // All logic is handled by runActiveAnimations.
            // We keep it here to prevent breaking old calls, but it does nothing.
        }
        
        // Gets the "final" assembled position for a piece
        function getAssembledPosition(mesh) {
            const a = valA;
            const b = valB;
            const amb = valAminusB;
            const offset = -a / 2;

            const mainPos = offset + amb / 2;
            const slabPos = offset + amb / 2;
            const slabPosB = offset + amb + b / 2;
            const stickPos = offset + amb / 2;
            const stickPosB = offset + amb + b / 2;
            const cornerPos = offset + amb + b / 2;
            
            if (mesh === meshes.main) return new THREE.Vector3(mainPos, mainPos, mainPos);
            if (mesh === meshes.slab1) return new THREE.Vector3(slabPos, slabPos, slabPosB);
            if (mesh === meshes.slab2) return new THREE.Vector3(slabPos, slabPosB, slabPos);
            if (mesh === meshes.slab3) return new THREE.Vector3(slabPosB, slabPos, slabPos);
            if (mesh === meshes.stick1) return new THREE.Vector3(stickPos, stickPosB, stickPosB);
            if (mesh === meshes.stick2) return new THREE.Vector3(stickPosB, slabPos, stickPosB);
            if (mesh === meshes.stick3) return new THREE.Vector3(stickPosB, stickPosB, slabPos);
            if (mesh === meshes.corner) return new THREE.Vector3(cornerPos, cornerPos, cornerPos);
            
            return new THREE.Vector3(0,0,0);
        }
        
        // --- NEW: Gets assembled position for 2D planes ---
        function get2DAssembledPos(plane) {
            const a = valA;
            const b = valB;
            const amb = valAminusB;
            const offset = -a / 2;

            const mainPosVal = offset + amb / 2;
            const bPosVal = offset + amb + b / 2;
            
            const mainPos = new THREE.Vector3(mainPosVal, mainPosVal, 0.1);
            const bPos = new THREE.Vector3(bPosVal, bPosVal, 0.1);
            const amb1Pos = new THREE.Vector3(mainPosVal, bPosVal, 0.1);
            const amb2Pos = new THREE.Vector3(bPosVal, mainPosVal, 0.1);

            if (plane === planes.main_plane) return mainPos;
            if (plane === planes.b_plane) return bPos;
            if (plane === planes.amb_plane1) return amb1Pos;
            if (plane === planes.amb_plane2) return amb2Pos;
            
            return new THREE.Vector3(0,0,0);
        }
        
        // Gets exploded position for 2D planes
        function get2DExplodedPos(plane, stage = 2) {
            const a = valA;
            const b = valB;
            const amb = valAminusB;
            const offset = -a / 2;
            const e = valB * 0.5; // 2D explode factor
            
            const mainPos = offset + amb / 2;
            const bPos = offset + amb + b / 2;
            
            // STAGE 1: Vertical Split Only
            if (stage === 1) {
                if (plane === planes.vert_plane_amb) return new THREE.Vector3(mainPos - e, 0, 0.1);
                if (plane === planes.vert_plane_b) return new THREE.Vector3(bPos + e, 0, 0.1);
            }
            
            // STAGE 2: Full Split
            if (stage === 2) {
                if (plane === planes.main_plane) return new THREE.Vector3(mainPos - e, mainPos - e, 0.1); // Blue
                if (plane === planes.b_plane) return new THREE.Vector3(bPos + e, bPos + e, 0.1); // Red
                if (plane === planes.amb_plane1) return new THREE.Vector3(mainPos - e, bPos + e, 0.1); // Yellow 1
                if (plane === planes.amb_plane2) return new THREE.Vector3(bPos + e, mainPos - e, 0.1); // Yellow 2
            }
            
            return new THREE.Vector3(0,0,0);
        }

        // Gets exploded position for 3D cubes
        function get3DExplodedPos(mesh) {
            const a = valA;
            const b = valB;
            const amb = valAminusB;
            const offset = -a / 2;
            const e = valB * 1.5; // 3D explode factor

            const mainPos = offset + amb / 2;
            const slabPos = offset + amb / 2;
            const slabPosB = offset + amb + b / 2;
            const stickPos = offset + amb / 2;
            const stickPosB = offset + amb + b / 2;
            const cornerPos = offset + amb + b / 2;

            if (mesh === meshes.main) return new THREE.Vector3(mainPos - e, mainPos - e, mainPos - e);
            if (mesh === meshes.slab1) return new THREE.Vector3(slabPos, slabPos, slabPosB + e); 
            if (mesh === meshes.slab2) return new THREE.Vector3(slabPos, slabPosB + e, slabPos); 
            if (mesh === meshes.slab3) return new THREE.Vector3(slabPosB + e, slabPos, slabPos); 
            if (mesh === meshes.stick1) return new THREE.Vector3(stickPos, stickPosB + e, slabPosB + e);
            if (mesh === meshes.stick2) return new THREE.Vector3(slabPosB + e, slabPos, slabPosB + e);
            if (mesh === meshes.stick3) return new THREE.Vector3(slabPosB + e, stickPosB + e, slabPos); 
            if (mesh === meshes.corner) return new THREE.Vector3(cornerPos + e, cornerPos + e, cornerPos + e);
            
            return new THREE.Vector3(0,0,0);
        }


        function flashWrong(mesh) {
            if (!mesh || !mesh.material || mesh.userData.isFlashing || mesh.userData.isRemoving) return;

            // Check if material has userData.originalColor
            if (mesh.isMesh && mesh.material.userData && mesh.material.userData.originalColor !== undefined) {
                mesh.userData.isFlashing = true;
                const originalColor = mesh.material.userData.originalColor;
                mesh.material.color.setHex(0xffaa00); // Flash Orange/Yellow
                setTimeout(() => {
                    if (mesh && mesh.material) { // Check if mesh still exists
                        mesh.material.color.setHex(originalColor);
                        mesh.userData.isFlashing = false;
                    }
                }, 300);
            } else {
                // It's a mesh/object we don't know how to flash, so do nothing.
            }
        }
        
        // NEW: Helper to find a label name for a mesh
        function getLabelForMesh(mesh) {
            if (mesh === meshes.main) return 'amb_cube';
            if (mesh === meshes.slab1) return 'slab';
            if (mesh === meshes.slab2) return 'slab2';
            if (mesh === meshes.slab3) return 'slab3';
            if (mesh === meshes.stick1) return 'stick';
            if (mesh === meshes.stick2) return 'stick2';
            if (mesh === meshes.stick3) return 'stick3';
            if (mesh === meshes.corner) return 'corner';
            return null;
        }

        // --- Asset Creation ---

        function createGeometries() {
            // 3D
            geometries.main = new THREE.BoxGeometry(1, 1, 1);
            geometries.slab = new THREE.BoxGeometry(1, 1, 1);
            geometries.stick = new THREE.BoxGeometry(1, 1, 1);
            geometries.corner = new THREE.BoxGeometry(1, 1, 1);
            geometries.a_cube = new THREE.BoxGeometry(1, 1, 1);
            
            // 2D (thin box)
            geometries.plane = new THREE.BoxGeometry(1, 1, 0.05);
            
            // 1D (very thin box)
            geometries.line = new THREE.BoxGeometry(1, 0.1, 0.1); 
        }
        
        function createMeshes() { // 3D Cubes
            meshes.main = new THREE.Mesh(geometries.main, materials.main);
            meshes.slab1 = new THREE.Mesh(geometries.slab, materials.slab);
            meshes.slab2 = new THREE.Mesh(geometries.slab, materials.slab2); // Use unique material
            meshes.slab3 = new THREE.Mesh(geometries.slab, materials.slab3); // Use unique material
            meshes.stick1 = new THREE.Mesh(geometries.stick, materials.stick);
            meshes.stick2 = new THREE.Mesh(geometries.stick, materials.stick2); // Use unique material
            meshes.stick3 = new THREE.Mesh(geometries.stick, materials.stick3); // Use unique material
            meshes.corner = new THREE.Mesh(geometries.corner, materials.corner);
            meshes.a_cube = new THREE.Mesh(geometries.a_cube, materials.a_cube);
            
            mainGroup.add(meshes.main, meshes.slab1, meshes.slab2, meshes.slab3, 
                            meshes.stick1, meshes.stick2, meshes.stick3, meshes.corner, 
                            meshes.a_cube);
            
            // Add outlines *only* to the 8 pieces, not a_cube
            const pieces = [meshes.main, meshes.slab1, meshes.slab2, meshes.slab3, meshes.stick1, meshes.stick2, meshes.stick3, meshes.corner];
            for (const mesh of pieces) {
                if (mesh.geometry) {
                    const outline = new THREE.LineSegments(
                        new THREE.EdgesGeometry(mesh.geometry),
                        materials.outline
                    );
                    mesh.add(outline);
                    mesh.userData.outline = outline;
                }
            }
        }
        
        function create2DPlanes() {
            // Final 4 pieces
            planes.a_plane = new THREE.Mesh(geometries.plane, materials.a_plane);
            planes.main_plane = new THREE.Mesh(geometries.plane, materials.main_plane);
            planes.b_plane = new THREE.Mesh(geometries.plane, materials.b_plane);
            planes.amb_plane1 = new THREE.Mesh(geometries.plane, materials.amb_plane);
            planes.amb_plane2 = new THREE.Mesh(geometries.plane, materials.amb_plane.clone()); // Use unique material
            // Vertical split pieces
            planes.vert_plane_amb = new THREE.Mesh(geometries.plane, materials.vert_plane_amb);
            planes.vert_plane_b = new THREE.Mesh(geometries.plane, materials.vert_plane_b);

            mainGroup.add(planes.a_plane, planes.main_plane, planes.b_plane, planes.amb_plane1, planes.amb_plane2, planes.vert_plane_amb, planes.vert_plane_b);
        }

        // Create Line Meshes (1D)
        function createLineMeshes() { 
            lines.line_a = new THREE.Mesh(geometries.line, materials.line_a); 
            lines.line_b = new THREE.Mesh(geometries.line, materials.line_b);
            lines.line_amb = new THREE.Mesh(geometries.line, materials.line_amb);

            mainGroup.add(lines.line_a, lines.line_b, lines.line_amb); 
        }
        
        function createLabels() {
            const createLabel = (text, className = 'label') => {
                const div = document.createElement('div');
                div.className = className;
                div.textContent = text;
                const label = new THREE.CSS2DObject(div); 
                label.visible = false; // Hide by default
                return label;
            };
            
            // 1D Labels
            labels.a_line = createLabel('a'); 
            labels.b_line = createLabel('b');
            labels.amb_line = createLabel('a-b');
            
            // 2D Area Labels
            labels.a_plane = createLabel('a²');
            labels.amb_plane = createLabel('(a-b)²');
            labels.b_plane = createLabel('b²');
            labels.b_amb_plane = createLabel('b(a-b)');
            labels.b_amb_plane2 = createLabel('b(a-b)'); 
            
            // 2D Dimension (Side) Labels
            labels.dim_a_horiz = createLabel('a', 'dim-label'); // Bottom
            labels.dim_a_vert = createLabel('a', 'dim-label'); // Left
            
            labels.dim_amb_horiz = createLabel('a-b', 'dim-label'); // bottom
            labels.dim_amb_vert = createLabel('a-b', 'dim-label'); // left
            
            labels.dim_b_horiz = createLabel('b', 'dim-label'); // bottom
            labels.dim_b_vert = createLabel('b', 'dim-label'); // left
            
            // Yellow Rect 1 (amb_plane1)
            labels.dim_amb_horiz2 = createLabel('a-b', 'dim-label'); // bottom
            labels.dim_b_vert2 = createLabel('b', 'dim-label'); // left

            // Yellow Rect 2 (amb_plane2)
            labels.dim_b_horiz2 = createLabel('b', 'dim-label'); // bottom
            labels.dim_amb_vert2 = createLabel('a-b', 'dim-label'); // left
            
            // NEW: Labels for Vertical Split
            labels.vert_area_amb = createLabel('a(a-b)'); // Removed dim-label class
            labels.vert_area_b = createLabel('a(b)'); // Removed dim-label class


            // 3D Labels
            labels.amb_cube = createLabel('(a-b)³');
            labels.slab = createLabel('b(a-b)²');
            labels.slab2 = createLabel('b(a-b)²'); // NEW
            labels.slab3 = createLabel('b(a-b)²'); // NEW
            labels.stick = createLabel('b²(a-b)');
            labels.stick2 = createLabel('b²(a-b)'); // NEW
            labels.stick3 = createLabel('b²(a-b)'); // NEW
            labels.corner = createLabel('b³');
            labels.a_cube = createLabel('a³');
            
            // Add line labels to lines
            lines.line_a.add(labels.a_line); 
            labels.a_line.position.set(0, 0.5, 0); // Position above line
            lines.line_b.add(labels.b_line); 
            labels.b_line.position.set(0, 0.5, 0);
            lines.line_amb.add(labels.amb_line); 
            labels.amb_line.position.set(0, 0.5, 0);
            
            // Add 2D Area labels to planes
            planes.a_plane.add(labels.a_plane);
            planes.main_plane.add(labels.amb_plane);
            planes.b_plane.add(labels.b_plane);
            planes.amb_plane1.add(labels.b_amb_plane);
            planes.amb_plane2.add(labels.b_amb_plane2); 
            
            // Add 2D Dimension labels to planes (2 sides only)
            planes.a_plane.add(labels.dim_a_horiz, labels.dim_a_vert);
            planes.main_plane.add(labels.dim_amb_horiz, labels.dim_amb_vert);
            planes.b_plane.add(labels.dim_b_horiz, labels.dim_b_vert);
            planes.amb_plane1.add(labels.dim_amb_horiz2, labels.dim_b_vert2);
            planes.amb_plane2.add(labels.dim_b_horiz2, labels.dim_amb_vert2);
            
            // Add Vertical Split labels
            planes.vert_plane_amb.add(labels.vert_area_amb); // Only add area label
            planes.vert_plane_b.add(labels.vert_area_b); // Only add area label


            // Add 3D labels to cubes
            meshes.main.add(labels.amb_cube);
            meshes.slab1.add(labels.slab); 
            meshes.slab2.add(labels.slab2); // NEW
            meshes.slab3.add(labels.slab3); // NEW
            meshes.stick1.add(labels.stick); 
            meshes.stick2.add(labels.stick2); // NEW
            meshes.stick3.add(labels.stick3); // NEW
            meshes.corner.add(labels.corner);
            meshes.a_cube.add(labels.a_cube);
            
            // Center all child labels
            for (const parent of [...Object.values(meshes), ...Object.values(planes)]) { 
                parent.children.forEach(child => {
                    if (child.isCSS2DObject && (child.element.className.includes('label') || child.element.className.includes('dim-label'))) {
                        // Position Area labels centrally
                        child.position.set(0, 0, 0.2); // Slightly above plane/cube face
                    }
                });
            }
        }
        
        // --- Asset Updates ---
        
        // Update Line Meshes (1D)
        function updateLineMeshes(a, b) {
            const amb = a - b;
            const start_x = -a / 2; // Left edge of 'a'
            const mid_x = start_x + amb; // Split point
            
            const y_pos = 0; 
            const z_pos = 0;
            
            // 'a' line
            lines.line_a.scale.set(a, 1, 1);
            lines.line_a.position.set(0, y_pos, z_pos);
            
            // 'a-b' line (blue)
            lines.line_amb.scale.set(amb, 1, 1); 
            lines.line_amb.position.set(start_x + (amb / 2), y_pos, z_pos);

            // 'b' line (red)
            lines.line_b.scale.set(b, 1, 1);
            lines.line_b.position.set(mid_x + (b / 2), y_pos, z_pos);
            
            setAllLines(true);
        }
        
        function update2DPlanes(a, b) {
            const amb = a - b;
            const offset = -a / 2;
            
            // Full a^2 plane
            planes.a_plane.scale.set(a, a, 1);
            planes.a_plane.position.set(0, 0, 0);

            // Final 4 pieces
            const mainPos = offset + amb / 2;
            planes.main_plane.scale.set(amb, amb, 1);
            //planes.main_plane.position.set(mainPos, mainPos, 0.1); // Position set by animation

            const bPos = offset + amb + b / 2;
            planes.b_plane.scale.set(b, b, 1);
            //planes.b_plane.position.set(bPos, bPos, 0.1);
            
            planes.amb_plane1.scale.set(amb, b, 1);
            //planes.amb_plane1.position.set(mainPos, bPos, 0.1);
            
            planes.amb_plane2.scale.set(b, amb, 1);
            //planes.amb_plane2.position.set(bPos, mainPos, 0.1);
            
            // Vertical Split Pieces
            planes.vert_plane_amb.scale.set(amb, a, 1);
            //planes.vert_plane_amb.position.set(mainPos, 0, 0.1);
            
            planes.vert_plane_b.scale.set(b, a, 1);
            //planes.vert_plane_b.position.set(bPos, 0, 0.1);


            // --- Update Dimension Label Positions ---
            // Positions are relative to the 1x1 geometry.
            const labelOffset = 0.3; // Closer offset
            
            // 'a' labels (on a_plane)
            labels.dim_a_horiz.position.set(0, -0.5 - labelOffset, 0.2); // Bottom
            labels.dim_a_vert.position.set(-0.5 - labelOffset, 0, 0.2); // Left
            
            // 'a-b' labels (for blue square, main_plane)
            labels.dim_amb_horiz.position.set(0, -0.5 - labelOffset, 0.2); // Bottom
            labels.dim_amb_vert.position.set(-0.5 - labelOffset, 0, 0.2); // Left
            
            // 'b' labels (for red square, b_plane)
            labels.dim_b_horiz.position.set(0, -0.5 - labelOffset, 0.2); // Bottom
            labels.dim_b_vert.position.set(-0.5 - labelOffset, 0, 0.2); // Left
            
            // Labels for Yellow Rect 1 (amb_plane1)
            labels.dim_amb_horiz2.position.set(0, -0.5 - labelOffset, 0.2); // 'a-b' bottom
            labels.dim_b_vert2.position.set(-0.5 - labelOffset, 0, 0.2); // 'b' left

            // Labels for Yellow Rect 2 (amb_plane2)
            labels.dim_b_horiz2.position.set(0, -0.5 - labelOffset, 0.2); // 'b' bottom
            labels.dim_amb_vert2.position.set(-0.5 - labelOffset, 0, 0.2); // 'a-b' left
            
            setAllPlanes(true);
        }

        function updateMeshes(a, b) {
            valA = a;
            valB = b;
            valAminusB = a - b;
            
            for (const mesh of [...Object.values(meshes), ...Object.values(lines), ...Object.values(planes)]) {
                mesh.userData.isFadingOut = false; // Reset fade flag
                if (mesh.material) {
                    // Reset opacity and transparency
                    mesh.material.opacity = 1;
                    mesh.material.transparent = false;
                    
                    // Reset custom states
                    mesh.userData.isRemoving = false;
                    
                    // Reset color
                    if (mesh.material.userData.originalColor) {
                        mesh.material.color.setHex(mesh.material.userData.originalColor);
                    }
                }
            }
             // Reset special 'a_cube' and 'a_plane' materials that have default transparency
            materials.a_cube.opacity = 1.0; 
            materials.a_cube.transparent = false;
            materials.a_plane.opacity = 0.6;
            materials.a_plane.transparent = true;
            materials.vert_plane_amb.opacity = 0.8;
            materials.vert_plane_amb.transparent = true;
            materials.vert_plane_b.opacity = 0.8;
            materials.vert_plane_b.transparent = true;
            
            // Set all pieces to their correct ASSEMBLED positions
            meshes.main.scale.set(valAminusB, valAminusB, valAminusB);
            meshes.main.position.copy(getAssembledPosition(meshes.main));
            
            meshes.slab1.scale.set(valAminusB, valAminusB, valB);
            meshes.slab1.position.copy(getAssembledPosition(meshes.slab1));
            
            meshes.slab2.scale.set(valAminusB, valB, valAminusB);
            meshes.slab2.position.copy(getAssembledPosition(meshes.slab2));
            
            meshes.slab3.scale.set(valB, valAminusB, valAminusB);
            meshes.slab3.position.copy(getAssembledPosition(meshes.slab3));

            meshes.stick1.scale.set(valAminusB, valB, valB);
            meshes.stick1.position.copy(getAssembledPosition(meshes.stick1));
            
            meshes.stick2.scale.set(valB, valAminusB, valB);
            meshes.stick2.position.copy(getAssembledPosition(meshes.stick2));
            
            meshes.stick3.scale.set(valB, valB, valAminusB);
            meshes.stick3.position.copy(getAssembledPosition(meshes.stick3));
            
            meshes.corner.scale.set(valB, valB, valB);
            meshes.corner.position.copy(getAssembledPosition(meshes.corner));
            
            meshes.a_cube.scale.set(valA, valA, valA);
            meshes.a_cube.position.set(0, 0, 0);
            
            // Update outlines and labels
            for (const mesh of [...Object.values(meshes), ...Object.values(planes), ...Object.values(lines)]) { 
                if (mesh.userData.outline) { // For cubes
                    mesh.userData.outline.scale.set(
                        1 / mesh.scale.x, 1 / mesh.scale.y, 1 / mesh.scale.z
                    ).clampScalar(0.001, 1000);
                }
                
                // Rescale all labels to counteract parent scale
                mesh.children.forEach(child => { 
                    if (child.isCSS2DObject) {
                        const baseScale = 0.5; // Smaller base scale for labels
                        child.scale.set(
                            baseScale / mesh.scale.x, 
                            baseScale / mesh.scale.y, 
                            baseScale / mesh.scale.z
                        ).clampScalar(0.01, 100); // Prevent inversion
                    }
                });
            }
        }
        
        // --- Step Logic ---
        
        function setAllMeshes(visibility) {
            for (const mesh of Object.values(meshes)) {
                if (mesh.isMesh) mesh.visible = visibility;
            }
        }
        
        function setAllLines(visibility) {
            for (const key in lines) {
                if (lines[key].isMesh) lines[key].visible = visibility; 
            }
        }
        
        function setAllPlanes(visibility) {
            for (const plane of Object.values(planes)) {
                if (plane.isMesh) plane.visible = visibility;
            }
        }

        function setAllLabels(visibility) {
            for (const label of Object.values(labels)) {
                label.visible = visibility;
            }
        }
        
        // Helper to set visibility for a group of labels
        function setLabelGroupVisibility(labelNames, visibility) {
            labelNames.forEach(name => {
                if (labels[name]) {
                    labels[name].visible = visibility;
                }
            });
        }

        function clearScene() {
            setAllMeshes(false);
            setAllLines(false);
            setAllPlanes(false);
            setAllLabels(false);
            
            // Clear all active animations
            animatingObjects = [];
        }
        
        // --- Button Handlers ---

        window.handleStep1Click = function(stage) {
            const btn1 = document.getElementById('step-1-btn-1');
            const btn2 = document.getElementById('step-1-btn-2');

            if (stage === 1) { // Split 'a'
                stepState.step1_a_clicked = true;
                
                lines.line_a.visible = false;
                labels.a_line.visible = false;
                
                lines.line_amb.visible = true;
                lines.line_b.visible = true;
                labels.amb_line.visible = true;
                labels.b_line.visible = true;
                
                btn1.textContent = "Line Split!";
                btn1.className = "sim-button success";
                btn1.disabled = true;
                btn2.style.display = 'block';
            } else if (stage === 2) { // Remove 'b'
                stepState.step1_b_removed = true;
                
                removePiece(lines.line_b); // This now starts a fade-out
                // label is hidden in removePiece
                
                btn2.textContent = "'b' Removed!";
                btn2.className = "sim-button success";
                btn2.disabled = true;
            } else if (stage === 3) { // NEW: Reset
                stepState.step1_a_clicked = false;
                stepState.step1_b_removed = false;
                goToStep(1); // Resets the scene and calls updateFeedback
            }
        }
        
        window.handleStep2Click = function(stage) {
            const btn1 = document.getElementById('step-2-btn-1');
            const btn2 = document.getElementById('step-2-btn-2');
            const textEl = document.getElementById('step-2-text');

            if (stage === 1 && !stepState.step2_vertical_split) { // Vertical Split
                stepState.step2_vertical_split = true;
                
                // Start fading out 'a' plane
                startAnimation(planes.a_plane, null, 0.0, 0.05);
                setLabelGroupVisibility(['a_plane', 'dim_a_horiz', 'dim_a_vert'], false);

                // Show vertical split planes and animate them
                const vertPlanes = [planes.vert_plane_amb, planes.vert_plane_b];
                vertPlanes.forEach(plane => {
                    plane.visible = true;
                    const startPos = new THREE.Vector3().copy(get2DAssembledPos(plane));
                    startPos.y = 0; // Assembled Y
                    startPos.x = 0; // Start from center X
                    const endPos = get2DExplodedPos(plane, 1);
                    startAnimation(plane, endPos, 0.8, 0.03); // Animate to pos and fade in
                });
                // *** FIX: Only show AREA labels ***
                setLabelGroupVisibility(['vert_area_amb', 'vert_area_b'], true);

                updateFeedback(); // This will update buttons and text

            } else if (stage === 2 && !stepState.step2_horizontal_split) { // Horizontal Split
                stepState.step2_horizontal_split = true;
                
                // Start fading out vertical planes
                startAnimation(planes.vert_plane_amb, null, 0.0, 0.05);
                startAnimation(planes.vert_plane_b, null, 0.0, 0.05);
                // *** FIX: Hide the AREA labels we just showed ***
                setLabelGroupVisibility(['vert_area_amb', 'vert_area_b'], false);

                // Show final 4 planes and animate them
                const finalPlanes = [planes.main_plane, planes.b_plane, planes.amb_plane1, planes.amb_plane2];
                finalPlanes.forEach(plane => {
                    plane.visible = true;
                    // Start from the "assembled" vertical position
                    const startPos = get2DExplodedPos(plane, 1); // Start from vertical split pos
                    startPos.y = 0; // Assembled Y
                    const endPos = get2DExplodedPos(plane, 2);
                    startAnimation(plane, endPos, 1.0, 0.03); // Animate to pos and fade in
                });
                setLabelGroupVisibility(['amb_plane', 'b_plane', 'b_amb_plane', 'b_amb_plane2', 'dim_amb_horiz', 'dim_amb_vert', 'dim_b_horiz', 'dim_b_vert', 'dim_amb_horiz2', 'dim_b_vert2', 'dim_b_horiz2', 'dim_amb_vert2'], true);
                
                updateFeedback(); // This will update buttons and text

            } else if (stage === 3) { // NEW: Reset/Merge
                stepState.step2_vertical_split = false;
                stepState.step2_horizontal_split = false;
                goToStep(2); // This will reset the scene and call updateFeedback
            }
        }
        
        // --- Feedback and UI Updates ---
        function updateFeedback() {
            
            // Step 1
            const btn1_1 = document.getElementById('step-1-btn-1');
            const btn1_2 = document.getElementById('step-1-btn-2');
            const btn1_reset = document.getElementById('step-1-btn-reset'); // NEW
            if (btn1_1) {
                btn1_1.disabled = stepState.step1_a_clicked;
                btn1_1.className = stepState.step1_a_clicked ? "sim-button success" : "sim-button";
                btn1_1.textContent = stepState.step1_a_clicked ? "Line Split!" : "Split Line 'a'";
            }
            if (btn1_2) {
                btn1_2.style.display = stepState.step1_a_clicked ? 'block' : 'none';
                btn1_2.disabled = stepState.step1_b_removed;
                btn1_2.className = stepState.step1_b_removed ? "sim-button success" : "sim-button";
                btn1_2.textContent = stepState.step1_b_removed ? "'b' Removed!" : "Remove 'b'";
                
                if(btn1_reset) btn1_reset.style.display = stepState.step1_a_clicked ? 'block' : 'none'; // NEW
            }
            
            // Step 2
            const btn2_1 = document.getElementById('step-2-btn-1');
            const btn2_2 = document.getElementById('step-2-btn-2');
            const textEl = document.getElementById('step-2-text');
            const formulaEl = document.getElementById('step-2-formula');
            const btn2_reset = document.getElementById('step-2-btn-reset');

            if (btn2_1 && textEl && formulaEl && btn2_reset) {
                btn2_1.disabled = stepState.step2_vertical_split;
                btn2_1.className = stepState.step2_vertical_split ? "sim-button success" : "sim-button";
                btn2_1.textContent = stepState.step2_vertical_split ? "Vertical Split!" : "1. Make Vertical Split";
                
                btn2_2.style.display = stepState.step2_vertical_split ? 'block' : 'none';
                btn2_2.disabled = stepState.step2_horizontal_split;
                btn2_2.className = stepState.step2_horizontal_split ? "sim-button success" : "sim-button";
                btn2_2.textContent = stepState.step2_horizontal_split ? "Horizontal Split!" : "2. Make Horizontal Split";
                
                // Update text based on state
                if (!stepState.step2_vertical_split) {
                    textEl.innerHTML = "<b>Now, let's apply that same logic to a 2D square with area a².<br><br>We will split the square by \"cutting\" it. This is a two-step process.</b>";
                } else if (!stepState.step2_horizontal_split) {
                    textEl.innerHTML = "<b>Great! We now have two tall rectangles: a(a-b) and a(b).<br><br>Now, let's make a horizontal split to cut <i>both</i> of these new rectangles.</b>";
                } else {
                    textEl.innerHTML = "<b>Watch! The left a(a-b) rectangle splits into (a-b)² and b(a-b).<br>The right a(b) rectangle splits into b(a-b) and b².</b>";
                }
                
                // Show/hide formula and reset button
                formulaEl.style.display = stepState.step2_horizontal_split ? 'block' : 'none';
                btn2_reset.style.display = stepState.step2_horizontal_split ? 'block' : 'none';
            }

            // NEW: Step 3 Feedback
            const feedback3 = document.getElementById('step-3-feedback');
            const formula3 = document.getElementById('step-3-formula');
            const reset3 = document.getElementById('step-3-btn-reset');
            const text3 = document.getElementById('step-3-text');

            if (feedback3 && formula3 && reset3 && text3) {
                // Default states
                formula3.style.display = 'none';
                reset3.style.display = 'none';
                
                switch (stepState.step3_stage) {
                    case 0:
                        text3.innerHTML = "<b>Great! Now we apply the *exact same logic* to 3D.<br><br>We start with a big cube of volume a³.</b>";
                        feedback3.textContent = "Click the large 'a³' cube to split it into its 8 pieces.";
                        feedback3.className = "feedback";
                        break;
                    case 1:
                        text3.innerHTML = "<b>Perfect! The cube is split.<br><br>To find the blue (a-b)³ cube, we must remove the 7 other pieces.</b>";
                        feedback3.textContent = `First, click the ${stepState.step3_piecesLeft} remaining green slabs.`;
                        feedback3.className = "feedback subtract";
                        break;
                    case 2:
                        text3.innerHTML = "<b>Great! The slabs are gone.</b>";
                        feedback3.textContent = `Now, click the ${stepState.step3_piecesLeft} remaining yellow sticks.`;
                        feedback3.className = "feedback subtract";
                        break;
                    case 3:
                        text3.innerHTML = "<b>Almost there! The sticks are gone.</b>";
                        feedback3.textContent = `Finally, click the 1 red corner cube.`;
                        feedback3.className = "feedback subtract";
                        break;
                    case 4:
                        text3.innerHTML = "<b>Congratulations!</b>";
                        feedback3.textContent = "You did it! You've found the (a-b)³ cube.";
                        feedback3.className = "feedback success";
                        formula3.style.display = 'block'; // Show formula
                        reset3.style.display = 'block'; // Show reset button
                        break;
                }
            }
        }
        
        // This function is now globally accessible from the HTML onclick
        window.goToStep = function(step) {
            currentStep = step;
            
            // Update UI panels
            document.querySelectorAll('.step-header').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.step-description').forEach(el => el.style.display = 'none');
            
            const currentHeader = document.querySelector(`.step-header[onclick="goToStep(${step})"]`);
            if (currentHeader) currentHeader.classList.add('active');
            
            const currentDesc = document.getElementById(`step-${step}-desc`);
            if (currentDesc) currentDesc.style.display = 'block';
            
            // --- Handle 3D Scene ---
            
            // 1. Reset all pieces to their default assembled positions
            updateMeshes(valA, valB);
            updateLineMeshes(valA, valB);
            update2DPlanes(valA, valB);
            
            // 2. Hide everything
            clearScene();
            
            // 3. Set camera
            if (step >= 1 && step <= 2) {
                // 1D/2D View
                camera.position.set(0, 0, 10);
                controls.target.set(0, 0, 0);
                controls.enableRotate = false;
                controls.enableZoom = false;
            } else {
                // 3D View
                camera.position.set(valA * 1.5, valA * 1.5, valA * 1.5);
                controls.target.set(0, 0, 0);
                controls.enableRotate = true;
                controls.enableZoom = true;
            }
            controls.update(); // Apply camera changes
            
            // 4. Selectively show and position pieces for the current step
            const slabs = [meshes.slab1, meshes.slab2, meshes.slab3];
            const sticks = [meshes.stick1, meshes.stick2, meshes.stick3];
            const corner = meshes.corner;
            
            const all2DFinal = [planes.main_plane, planes.b_plane, planes.amb_plane1, planes.amb_plane2];
            const all2DVert = [planes.vert_plane_amb, planes.vert_plane_b];

            switch(step) {
                case 0: // Welcome
                    break;
                case 1: // 1D Journey
                    lines.line_a.visible = !stepState.step1_a_clicked;
                    labels.a_line.visible = !stepState.step1_a_clicked;
                    
                    lines.line_amb.visible = stepState.step1_a_clicked;
                    labels.amb_line.visible = stepState.step1_a_clicked;
                    
                    lines.line_b.visible = stepState.step1_a_clicked && !stepState.step1_b_removed;
                    labels.b_line.visible = stepState.step1_a_clicked && !stepState.step1_b_removed;
                    
                    updateFeedback(); 
                    break;
                case 2: // 2D Journey
                    // Show 'a' plane OR the split planes, based on state
                    planes.a_plane.visible = !stepState.step2_vertical_split;
                    setLabelGroupVisibility(['a_plane', 'dim_a_horiz', 'dim_a_vert'], !stepState.step2_vertical_split);

                    // Show vertical split
                    all2DVert.forEach(plane => {
                        plane.visible = stepState.step2_vertical_split && !stepState.step2_horizontal_split;
                        plane.position.copy(get2DExplodedPos(plane, 1)); // Set to final exploded pos
                    });
                    // *** FIX: Only show AREA labels ***
                    setLabelGroupVisibility(['vert_area_amb', 'vert_area_b'], stepState.step2_vertical_split && !stepState.step2_horizontal_split);

                    // Show horizontal (final) split
                    all2DFinal.forEach(plane => {
                        plane.visible = stepState.step2_horizontal_split;
                        plane.position.copy(get2DExplodedPos(plane, 2)); // Set to final exploded pos
                    });
                    setLabelGroupVisibility(['amb_plane', 'b_plane', 'b_amb_plane', 'b_amb_plane2', 'dim_amb_horiz', 'dim_amb_vert', 'dim_b_horiz', 'dim_b_vert', 'dim_amb_horiz2', 'dim_b_vert2', 'dim_b_horiz2', 'dim_amb_vert2'], stepState.step2_horizontal_split);

                    updateFeedback();
                    break;
                case 3: // The 3D Journey
                    // This is now the main interactive step
                    // Reset stage
                    stepState.step3_stage = 0;
                    stepState.step3_piecesLeft = 0;

                    // Show ONLY the a3 cube
                    meshes.a_cube.visible = true;
                    labels.a_cube.visible = true;
                    
                    // Hide all other 3D pieces
                    const allPieces = [meshes.main, meshes.slab1, meshes.slab2, meshes.slab3, meshes.stick1, meshes.stick2, meshes.stick3, meshes.corner];
                    allPieces.forEach(mesh => {
                        mesh.visible = false;
                        mesh.position.copy(getAssembledPosition(mesh)); // Reset position
                        mesh.userData.isRemoving = false; // NEW: Reset removing flag
                    });
                    setLabelGroupVisibility(['amb_cube', 'slab', 'slab2', 'slab3', 'stick', 'stick2', 'stick3', 'corner'], false);
                    
                    updateFeedback();
                    break;
                
                // REMOVED STEPS 4-12
                
                case 4: 
                case 5: 
                case 6: 
                case 7: 
                case 8: 
                case 9: 
                case 10: 
                case 11: 
                case 12: 
                    // Go to step 3 if somehow triggered
                    goToStep(3);
                    break;
            }
        }

        // --- Start ---
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
        
    </script>
</body>
</html>