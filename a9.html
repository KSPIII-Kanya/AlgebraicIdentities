<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kanya Sampoorna Project 3.0 - (a³ - b³)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
    
    <style>
        /* Basic Reset and Font */
        * { box-sizing: border-box; margin: 0; padding: 0; }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
            background-color: #f0f4f8;
            color: #333;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            position: relative; 
            width: 100%;
            background-color: #004a99;
            color: white;
            padding: 10px 20px;
            text-align: center;
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            line-height: 1.4;
            flex-shrink: 0;
        }

        .header h1 { font-size: 1.5rem; font-weight: bold; margin: 0; }
        .header p { font-size: 0.9rem; margin: 0; }
        
        /* Footer */
        .footer {
            position: relative; 
            width: 100%;
            background-color: #004a99;
            color: white;
            padding: 8px;
            text-align: center;
            z-index: 10;
            font-size: 0.8rem;
            flex-shrink: 0;
        }

        /* Content Area Wrapper */
        .content-area {
            flex-grow: 1; 
            display: flex;
            position: relative; 
            overflow: hidden; 
            height: 100%;
        }

        /* Main Layout Container */
        .main-container {
            display: flex;
            flex-direction: row;
            width: 100%;
            height: 100%;
        }

        /* Scene container */
        #scene-container {
            position: relative;
            flex-grow: 1; 
            height: 100%;
            z-index: 1;
            overflow: hidden; 
            cursor: default;
        }
        
        /* 3D Label CSS - CLEAN STICKER LOOK */
        .label {
            color: #000;
            font-family: 'Courier New', Courier, monospace;
            font-size: 24px; /* Big and bold */
            font-weight: 900;
            /* No background box for the shape labels */
            background: none; 
            border: none;
            padding: 0;
            pointer-events: none;
            white-space: nowrap;
            /* White text shadow to ensure readability on colored blocks */
            text-shadow: 
                -1px -1px 0 #fff,  
                 1px -1px 0 #fff,
                -1px  1px 0 #fff,
                 1px  1px 0 #fff;
            transition: all 0.3s ease;
            opacity: 0.9;
        }

        /* Height label keeps the box for clarity since it is floating */
        .label-height {
            background-color: #f8f9fa;
            border: 2px solid #6c757d;
            padding: 4px 8px;
            border-radius: 4px;
            color: #333;
            font-size: 18px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-shadow: none;
        }
        
        /* 3D Formula Container */
        #formula-container {
            padding: 12px 18px;
            text-align: center;
            width: auto;
            min-width: 300px; 
            background-color: rgba(255, 255, 255, 0.95);
            border: 2px solid #004a99;
            border-radius: 8px;
            pointer-events: none; 
            transition: opacity 0.3s;
            font-size: 1.2rem;
            white-space: nowrap;
        }
        
        /* UI Panel */
        .ui-panel {
            position: relative;
            flex-basis: 400px; 
            flex-shrink: 0;
            height: 100%;
            background-color: rgba(255, 255, 255, 1);
            border-left: 1px solid #ccc; 
            padding: 20px;
            z-index: 5;
            display: flex;
            flex-direction: column;
        }

        .ui-content {
            max-height: none;
            overflow-y: auto;
            flex-grow: 1; 
            padding-right: 10px; 
        }

        /* Step Navigation Styling */
        .step-header {
            cursor: pointer;
            padding: 12px 10px;
            border-radius: 8px;
            margin-bottom: 5px;
            background-color: #f4f4f4;
            transition: background-color 0.2s;
            border: 1px solid #eee;
        }
        
        .step-header:hover { background-color: #e9e9e9; }
        .step-header.active { background-color: #007bff; color: white; border-color: #007bff; }
        .step-header h2 { font-size: 1.1rem; margin-bottom: 0; color: #004a99; }
        .step-header.active h2 { color: white; }

        .step-description {
            display: none;
            padding: 10px 10px 15px 10px;
            border-bottom: 1px solid #eee;
            margin-bottom: 5px;
            background: #fafafa;
        }
        .step-header.active + .step-description { display: block; }
        .step-description p { font-size: 0.95rem; line-height: 1.5; margin-bottom: 10px; font-weight: bold; }
        .step-description p:last-child { margin-bottom: 0; }
        
        /* Button styles */
        .sim-button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            transition: background-color 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .sim-button:hover { background-color: #0056b3; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .sim-button:disabled { background-color: #c0c0c0; cursor: not-allowed; box-shadow: none; }
        .sim-button.success { background-color: #28a745; }
        .sim-button.reset { background-color: #dc3545; color: white; }
        .sim-button.reset:hover { background-color: #c82333; }
        .sim-button.menu { background-color: #007bff; color: white; }
        .sim-button.menu:hover { background-color: #0056b3; }

        /* Global Nav Buttons */
        .global-nav {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .global-button {
            flex-basis: 48%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        /* Feedback class for interactive step */
        .feedback {
            font-weight: bold;
            color: #004a99; /* Blue */
            background-color: #f4f8ff;
            border: 1px solid #b5cde5;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            transition: all 0.2s;
        }
        .feedback.highlight { color: #d9534f; background-color: #fff8f8; border: 1px solid #f0c0c0; }
        .feedback.success { color: #3c763d; background-color: #f4fcf4; border-color: #b5d5b5; }
        
        /* Algebra explanation styles */
        .algebra {
            background-color: #e6f0ff;
            border-radius: 8px;
            padding: 10px;
            font-family: "Courier New", Courier, monospace;
            font-size: 0.95rem;
            line-height: 1.6;
            margin-top: 10px;
        }
        .term { font-weight: bold; padding: 0 2px; }
        .term-a3 { color: #007bff; }
        .term-b3 { color: #d9534f; }
        .term-a2 { color: #28a745; } /* Green */
        .term-ab { color: #ffc107; } /* Yellow */
        .term-b2 { color: #fd7e14; } /* Orange */
        .term-ab-diff { color: #6c757d; }

        /* Highlight State for Formula Terms */
        .term-active {
            transform: scale(1.4);
            background-color: #fffacd;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 10;
            border-radius: 4px;
            display: inline-block;
        }

        /* Loading Screen */
        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            color: #004a99;
            z-index: 100;
        }

        @media (max-width: 800px) {
            .content-area { flex-direction: column; }
            .main-container { flex-direction: column; }
            #scene-container { flex-grow: 1; flex-basis: 60%; height: 60%; width: 100%; }
            .ui-panel { flex-basis: auto; flex-grow: 1; height: 40%; width: 100%; border-left: none; border-top: 1px solid #ccc; padding: 15px; }
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>Kanya Sampoorna Project 3.0 / Kanya Girls Education Project</h1>
        <p><b>The project is supported by TITAN and implemented by KALIKE</b></p>
        <p><b>AI-powered Math Simulation for fun, visual, and interactive learning of Algebraic Identities.</b></p>
    </div>
    
    <!-- 3D Formula Container -->
    <div id="formula-container" style="display:none;">
        <div id="formula-text">
            <span id="f-a3" class="term term-a3">a³</span> - <span id="f-b3" class="term term-b3">b³</span> = 
            (<span id="f-diff" class="term term-ab-diff">a-b</span>)(
            <span id="f-a2" class="term term-a2">a²</span> + 
            <span id="f-ab" class="term term-ab">ab</span> + 
            <span id="f-b2" class="term term-b2">b²</span>)
        </div>
    </div>
    
    <div class="content-area">
        <div id="loader">Loading 3D Simulation...</div>

        <div class="main-container">
            <div id="scene-container"></div>

            <div class="ui-panel">
                <div class="ui-content">
                    
                    <div class="global-nav">
                        <button class="global-button reset sim-button reset" onclick="location.reload()">Reset</button>
                        <button class="global-button menu sim-button menu" onclick="location.href='index.html'">Back to Menu</button>
                    </div>

                    <!-- STEP 0: Intro -->
                    <div class="step-header active" onclick="goToStep(0)">
                        <h2>Step 0: The Concept</h2>
                    </div>
                    <div class="step-description" id="step-0-desc">
                        <p><b>We want to find the formula for a³ - b³.
                        <br><br>
                        We start with a large Blue Cube (volume a³).
                        Inside it, notice the outline of a smaller Red Cube (volume b³) at the corner.</b></p>
                    </div>
                    
                    <!-- STEP 1: Remove b3 -->
                    <div class="step-header" onclick="goToStep(1)">
                        <h2>Step 1: Subtraction</h2>
                    </div>
                    <div class="step-description" id="step-1-desc">
                        <p><b>To calculate a³ - b³, we must subtract the smaller cube from the larger one.
                        <br><br>
                        Click the glowing Red Cube (b³) to remove it!</b></p>
                        <div class="feedback" id="step-1-feedback">Click the Red Cube!</div>
                    </div>
                    
                    <!-- STEP 2: Slice -->
                    <div class="step-header" onclick="goToStep(2)">
                        <h2>Step 2: Decomposition</h2>
                    </div>
                    <div class="step-description" id="step-2-desc">
                        <p><b>We are left with an irregular shape. To measure it, let's slice it into 3 regular prisms.
                        <br><br>
                        Click the remaining Blue shape to slice it!</b></p>
                        <div class="feedback" id="step-2-feedback">Click the remaining shape to slice!</div>
                    </div>

                    <!-- STEP 3: Rearrange -->
                    <div class="step-header" onclick="goToStep(3)">
                        <h2>Step 3: Rearrange & Prove</h2>
                    </div>
                    <div class="step-description" id="step-3-desc">
                        <p><b>We have 3 prisms. Let's rearrange them to see the formula.
                        <br><br>
                        Click any piece to align them side-by-side!</b></p>
                        <div class="feedback" id="step-3-feedback">Click a piece to arrange them!</div>
                        
                        <div id="final-proof" style="display:none; margin-top:15px;">
                            <p><b>Notice! All 3 prisms have the same height: h = (a-b).</b></p>
                            <div class="algebra">
                                <b>Total Volume = h × (Sum of Base Areas)</b><br>
                                = (a - b) × ( <span class="term term-a2">a²</span> + <span class="term term-ab">ab</span> + <span class="term term-b2">b²</span> )
                            </div>
                            <button class="sim-button" onclick="goToStep(0)" style="margin-top:10px; background-color:#6c757d;">Restart</button>
                        </div>
                    </div>
                    
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        <b>Powered by AI and Created by Kalike - An initiative of TATA Trusts.</b>
    </div>

    <script>
        // --- CONFIG ---
        const valA = 5;
        const valB = 2;
        let scene, camera, renderer, controls, labelRenderer;
        let mainGroup; 
        let raycaster, mouse;
        
        // --- STATE ---
        let currentStep = 0;
        const state = {
            b3Removed: false,
            sliced: false,
            arranged: false
        };
        let animatingObjects = [];

        // Globals for materials and meshes
        let materials = {};
        let meshes = {};
        let labels = {};
        
        // --- INIT ---
        function init() {
            try {
                const container = document.getElementById('scene-container');
                if (!container) return;

                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f4f8);

                // Camera setup
                camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.set(32, 22, 32); 
                camera.lookAt(0, 5, 0);

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(renderer.domElement);

                // Label Renderer
                labelRenderer = new THREE.CSS2DRenderer();
                labelRenderer.setSize(container.clientWidth, container.clientHeight);
                labelRenderer.domElement.style.position = 'absolute';
                labelRenderer.domElement.style.top = '0';
                labelRenderer.domElement.style.pointerEvents = 'none';
                container.appendChild(labelRenderer.domElement);

                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
                dirLight.position.set(10, 20, 10);
                scene.add(dirLight);

                // Controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.target.set(0, 5, 0);

                // Raycaster
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                // Mouse Events
                renderer.domElement.addEventListener('click', onMouseClick);
                renderer.domElement.addEventListener('mousemove', onMouseMove);
                window.addEventListener('resize', onWindowResize);

                // Group
                mainGroup = new THREE.Group();
                scene.add(mainGroup);

                initMaterials();
                createObjects();
                createFormulaLabel(); 
                
                goToStep(0);
                animate();
                
                document.getElementById('loader').style.display = 'none';
            } catch (e) {
                console.error("Initialization Error:", e);
                document.getElementById('loader').textContent = "Error loading simulation. Please refresh.";
            }
        }

        function initMaterials() {
            materials = {
                a3: new THREE.MeshLambertMaterial({ color: 0x007bff, transparent: true, opacity: 0.8 }), // Blue
                b3: new THREE.MeshLambertMaterial({ color: 0xd9534f, transparent: true, opacity: 1.0 }), // Red
                
                // Sliced Pieces colors
                p1: new THREE.MeshLambertMaterial({ color: 0x28a745 }), // Green (a^2)
                p2: new THREE.MeshLambertMaterial({ color: 0xffc107 }), // Yellow (ab)
                p3: new THREE.MeshLambertMaterial({ color: 0xfd7e14 }), // Orange (b^2)
                
                outline: new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
            };
        }

        // --- OBJECT CREATION ---
        function createObjects() {
            const a = valA;
            const b = valB;
            const diff = a - b;

            // 1. The "b^3" cube
            const geomB3 = new THREE.BoxGeometry(b, b, b);
            meshes.b3 = new THREE.Mesh(geomB3, materials.b3);
            meshes.b3.position.set(diff + b/2, diff + b/2, diff + b/2); 
            meshes.b3.name = "b3";
            
            // 2. Piece 1 (Bottom Slab)
            const geomP1 = new THREE.BoxGeometry(a, diff, a);
            meshes.p1 = new THREE.Mesh(geomP1, materials.a3); 
            meshes.p1.userData.finalMat = materials.p1; 
            meshes.p1.position.set(a/2, diff/2, a/2);
            meshes.p1.name = "p1";
            
            // 3. Piece 2 (Side Slab)
            const geomP2 = new THREE.BoxGeometry(diff, b, a);
            meshes.p2 = new THREE.Mesh(geomP2, materials.a3);
            meshes.p2.userData.finalMat = materials.p2; 
            meshes.p2.position.set(diff/2, diff + b/2, a/2);
            meshes.p2.name = "p2";

            // 4. Piece 3 (Corner Strip)
            const geomP3 = new THREE.BoxGeometry(b, b, diff);
            meshes.p3 = new THREE.Mesh(geomP3, materials.a3);
            meshes.p3.userData.finalMat = materials.p3; 
            meshes.p3.position.set(diff + b/2, diff + b/2, diff/2);
            meshes.p3.name = "p3";

            // Add outlines
            [meshes.b3, meshes.p1, meshes.p2, meshes.p3].forEach(m => {
                const edges = new THREE.EdgesGeometry(m.geometry);
                const line = new THREE.LineSegments(edges, materials.outline);
                m.add(line);
                mainGroup.add(m);
            });

            // Labels
            labels.b3 = createLabel("b³");
            updateLabelPosition(labels.b3, meshes.b3);
            scene.add(labels.b3);

            labels.p1 = createLabel("a²", "label label-p1");
            scene.add(labels.p1);
            
            labels.p2 = createLabel("ab", "label label-p2");
            scene.add(labels.p2);

            labels.p3 = createLabel("b²", "label label-p3");
            scene.add(labels.p3);

            labels.p1.visible = false;
            labels.p2.visible = false;
            labels.p3.visible = false;
            
            // Height Label
            labels.height = createLabel("h = a - b", "label label-height");
            scene.add(labels.height);
            labels.height.visible = false;
        }

        function createLabel(txt, className = "label") {
            const div = document.createElement('div');
            div.className = className;
            div.textContent = txt;
            const obj = new THREE.CSS2DObject(div);
            return obj;
        }
        
        function updateLabelPosition(label, mesh) {
            if(label && mesh) {
                label.position.copy(mesh.position);
            }
        }

        // NEW: Create Floating Formula in 3D
        function createFormulaLabel() {
            const formulaDiv = document.getElementById('formula-container');
            formulaDiv.style.display = 'block'; // Make visible for renderer
            labels.formula = new THREE.CSS2DObject(formulaDiv);
            // Position above the cube, lowered slightly to 1.7a
            labels.formula.position.set(valA/2, valA * 1.7, valA/2); 
            scene.add(labels.formula);
        }

        // --- HELPERS FOR FORMULA REACTION ---
        function highlightTerm(id, active) {
            const el = document.getElementById(id);
            if (el) {
                if (active) el.classList.add('term-active');
                else el.classList.remove('term-active');
            }
        }

        function resetFormulaHighlights() {
            ['f-a3', 'f-b3', 'f-diff', 'f-a2', 'f-ab', 'f-b2'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.className = el.className.replace(' term-active', '');
            });
        }

        // --- INTERACTION ---
        function onMouseMove(event) {
            event.preventDefault();
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(mainGroup.children, true);
            
            let hovered = null;
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                if (obj.type === 'LineSegments') obj = obj.parent;
                if (isInteractable(obj)) hovered = obj;
            }
            
            if (hovered) {
                document.body.style.cursor = 'pointer';
            } else {
                document.body.style.cursor = 'default';
            }
        }

        function isInteractable(obj) {
            if (currentStep === 1 && obj === meshes.b3 && !state.b3Removed) return true;
            if (currentStep === 2 && !state.sliced && (obj === meshes.p1 || obj === meshes.p2 || obj === meshes.p3)) return true;
            if (currentStep === 3 && !state.arranged && (obj === meshes.p1 || obj === meshes.p2 || obj === meshes.p3)) return true;
            return false;
        }

        function onMouseClick(event) {
            if (animatingObjects.length > 0) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(mainGroup.children, true);
            
            if (intersects.length > 0) {
                let obj = intersects[0].object;
                if (obj.type === 'LineSegments') obj = obj.parent;
                handleObjectClick(obj);
            }
        }

        function handleObjectClick(obj) {
            // STEP 1: Remove b3
            if (currentStep === 1 && obj === meshes.b3 && !state.b3Removed) {
                state.b3Removed = true;
                // Highlight b3 term in formula
                highlightTerm('f-b3', true);
                
                // Hide label immediately
                if (labels.b3) labels.b3.visible = false;

                startAnimation(meshes.b3, { x: valA + 2, y: valA + 2, z: valA + 2 }, true);
                
                document.getElementById('step-1-feedback').textContent = "Great! b³ is gone.";
                document.getElementById('step-1-feedback').className = "feedback success";
                setTimeout(() => {
                    highlightTerm('f-b3', false);
                    goToStep(2);
                }, 1500);
            }
            
            // STEP 2: Slice
            else if (currentStep === 2 && !state.sliced && (obj === meshes.p1 || obj === meshes.p2 || obj === meshes.p3)) {
                state.sliced = true;
                // React: Highlight LHS (a^3 - b^3) is done, now decomposing
                highlightTerm('f-a3', true);
                highlightTerm('f-b3', true);
                
                slicePieces();
                
                document.getElementById('step-2-feedback').textContent = "Slicing complete! 3 prisms found.";
                document.getElementById('step-2-feedback').className = "feedback success";
                setTimeout(() => {
                    highlightTerm('f-a3', false);
                    highlightTerm('f-b3', false);
                    goToStep(3);
                }, 2000);
            }
            
            // STEP 3: Arrange
            else if (currentStep === 3 && !state.arranged && (obj === meshes.p1 || obj === meshes.p2 || obj === meshes.p3)) {
                state.arranged = true;
                arrangePieces();
                
                // React: Highlight all factors
                highlightTerm('f-diff', true);
                highlightTerm('f-a2', true);
                highlightTerm('f-ab', true);
                highlightTerm('f-b2', true);
                
                document.getElementById('step-3-feedback').textContent = "They align perfectly. Common height is (a-b).";
                document.getElementById('step-3-feedback').className = "feedback success";
                document.getElementById('final-proof').style.display = 'block';
            }
        }

        // --- ANIMATION LOGIC ---
        function startAnimation(mesh, targetPos, fade = false) {
            animatingObjects.push({
                mesh: mesh,
                start: mesh.position.clone(),
                target: new THREE.Vector3(
                    targetPos.x !== undefined ? targetPos.x : mesh.position.x,
                    targetPos.y !== undefined ? targetPos.y : mesh.position.y,
                    targetPos.z !== undefined ? targetPos.z : mesh.position.z
                ),
                rotStart: mesh.rotation.clone(),
                rotTarget: targetPos.rot ? new THREE.Euler(targetPos.rot.x, targetPos.rot.y, targetPos.rot.z) : mesh.rotation.clone(),
                startTime: Date.now(),
                duration: 1000,
                fade: fade
            });
        }
        
        function slicePieces() {
            meshes.p1.material = meshes.p1.userData.finalMat;
            meshes.p2.material = meshes.p2.userData.finalMat;
            meshes.p3.material = meshes.p3.userData.finalMat;
            
            const gap = 0.2;
            startAnimation(meshes.p2, { x: meshes.p2.position.x - gap });
            startAnimation(meshes.p3, { z: meshes.p3.position.z - gap });
            
            setTimeout(() => {
                // For slice step, we'll just set them to the target positions
                if(labels.p1) {
                    labels.p1.position.copy(meshes.p1.position);
                    labels.p1.visible = true;
                }
                if(labels.p2) {
                    labels.p2.position.set(meshes.p2.position.x - gap, meshes.p2.position.y, meshes.p2.position.z);
                    labels.p2.visible = true;
                }
                if(labels.p3) {
                    labels.p3.position.set(meshes.p3.position.x, meshes.p3.position.y, meshes.p3.position.z - gap);
                    labels.p3.visible = true;
                }
            }, 1000);
        }

        function arrangePieces() {
            const a = valA;
            const b = valB;
            const diff = a - b;
            const spacing = 2.5; 

            const p1X = -a/2 - b/2 - spacing;
            const p3X = b + spacing;
            
            startAnimation(meshes.p1, { x: p1X, y: diff/2, z: 0 });
            
            startAnimation(meshes.p2, { 
                x: 0, 
                y: diff/2, 
                z: 0,
                rot: { x: 0, y: 0, z: -Math.PI/2 }
            });
            
            startAnimation(meshes.p3, { 
                x: p3X, 
                y: diff/2,
                z: 0,
                rot: { x: -Math.PI/2, y: 0, z: 0 }
            });
            
            setTimeout(() => {
                // Update Label Content
                if(labels.p1 && labels.p1.element) labels.p1.element.textContent = "a²";
                if(labels.p2 && labels.p2.element) labels.p2.element.textContent = "ab";
                if(labels.p3 && labels.p3.element) labels.p3.element.textContent = "b²";

                // STICK LABELS TO THE CENTER OF EACH SHAPE
                // We use the exact target coordinates of the meshes
                if(labels.p1) labels.p1.position.set(p1X, diff/2, 0);
                if(labels.p2) labels.p2.position.set(0, diff/2, 0);
                if(labels.p3) labels.p3.position.set(p3X, diff/2, 0);
                
                // SHOW HEIGHT LABEL - Far left
                if (labels.height) {
                    // Position it to the far left of the Green block (p1)
                    // P1 center is p1X, width is 'a' (5). Left edge is p1X - 2.5.
                    // Place label at p1X - 5.
                    labels.height.position.set(p1X - 5.0, diff/2, 0);
                    labels.height.visible = true;
                }
            }, 1000);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const now = Date.now();
            const finished = [];

            animatingObjects.forEach((anim, index) => {
                const elapsed = now - anim.startTime;
                let t = Math.min(elapsed / anim.duration, 1);
                t = 1 - Math.pow(1 - t, 3);

                anim.mesh.position.lerpVectors(anim.start, anim.target, t);
                
                anim.mesh.rotation.x = anim.rotStart.x + (anim.rotTarget.x - anim.rotStart.x) * t;
                anim.mesh.rotation.y = anim.rotStart.y + (anim.rotTarget.y - anim.rotStart.y) * t;
                anim.mesh.rotation.z = anim.rotStart.z + (anim.rotTarget.z - anim.rotStart.z) * t;

                if (anim.fade) {
                    anim.mesh.material.opacity = 0.9 * (1 - t);
                }

                if (t >= 1) {
                    finished.push(index);
                    if (anim.fade) anim.mesh.visible = false;
                }
            });

            for (let i = finished.length - 1; i >= 0; i--) {
                animatingObjects.splice(finished[i], 1);
            }

            if (currentStep === 1 && !state.b3Removed && meshes.b3) {
                const scale = 1 + Math.sin(Date.now() * 0.005) * 0.05;
                meshes.b3.scale.set(scale, scale, scale);
            }
            
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        // --- NAVIGATION ---
        window.goToStep = function(s) {
            currentStep = s;
            document.querySelectorAll('.step-header').forEach(e => e.classList.remove('active'));
            document.querySelectorAll('.step-description').forEach(e => e.style.display = 'none');
            
            const headers = document.querySelectorAll('.step-header');
            if(headers[s]) headers[s].classList.add('active');
            
            const descs = document.querySelectorAll('.step-description');
            if(descs[s]) descs[s].style.display = 'block';
            
            if (s === 0) resetSim();
        }

        function resetSim() {
            state.b3Removed = false;
            state.sliced = false;
            state.arranged = false;
            animatingObjects = [];
            resetFormulaHighlights();
            
            // Reset b3
            if (meshes.b3) {
                meshes.b3.visible = true;
                meshes.b3.material.opacity = 1.0;
                meshes.b3.scale.set(1,1,1);
                const a = valA; const b = valB; const diff = a - b;
                meshes.b3.position.set(diff + b/2, diff + b/2, diff + b/2);
                if(labels.b3) {
                     labels.b3.visible = true;
                     labels.b3.position.copy(meshes.b3.position);
                }
            }

            const a = valA; const b = valB; const diff = a - b;

            // Reset P1, P2, P3
            if(meshes.p1) {
                 meshes.p1.material = materials.a3;
                 meshes.p1.position.set(a/2, diff/2, a/2);
                 meshes.p1.rotation.set(0,0,0);
            }
            if(meshes.p2) {
                 meshes.p2.material = materials.a3;
                 meshes.p2.position.set(diff/2, diff + b/2, a/2);
                 meshes.p2.rotation.set(0,0,0);
            }
            if(meshes.p3) {
                 meshes.p3.material = materials.a3;
                 meshes.p3.position.set(diff + b/2, diff + b/2, diff/2);
                 meshes.p3.rotation.set(0,0,0);
            }
            
            // RESET LABELS CONTENT AND POSITION
            if(labels.p1) { 
                labels.p1.visible = false; 
                labels.p1.element.textContent = "a²"; 
                labels.p1.position.set(0,0,0); 
            }
            if(labels.p2) { 
                labels.p2.visible = false; 
                labels.p2.element.textContent = "ab"; 
                labels.p2.position.set(0,0,0);
            }
            if(labels.p3) { 
                labels.p3.visible = false; 
                labels.p3.element.textContent = "b²"; 
                labels.p3.position.set(0,0,0);
            }
            if(labels.b3) { labels.b3.visible = true; }
            
            // Hide height label on reset
            if(labels.height) labels.height.visible = false;
            
            document.getElementById('final-proof').style.display = 'none';
            const feedback1 = document.getElementById('step-1-feedback');
            if(feedback1) { feedback1.className = "feedback"; feedback1.textContent = "Click the Red Cube!"; }
            
            const feedback2 = document.getElementById('step-2-feedback');
            if(feedback2) { feedback2.className = "feedback"; feedback2.textContent = "Click the remaining shape to slice!"; }
            
            const feedback3 = document.getElementById('step-3-feedback');
            if(feedback3) { feedback3.className = "feedback"; feedback3.textContent = "Click a piece to arrange them!"; }
            
            if(camera) {
                camera.position.set(32, 22, 32);
                camera.lookAt(0, 5, 0);
                if (controls) controls.target.set(0, 5, 0);
            }
        }

        function onWindowResize() {
            const container = document.getElementById('scene-container');
            if(!container || !camera || !renderer) return;
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            labelRenderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        window.onload = init;

    </script>
</body>
</html>